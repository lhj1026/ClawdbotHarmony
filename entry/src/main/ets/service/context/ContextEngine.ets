/**
 * ContextEngine.ets â€” ArkTS wrapper for native context_engine C++ NAPI module
 *
 * æƒ…æ™¯æ™ºèƒ½è§„åˆ™å¼•æ“çš„ ArkTS å±‚:
 *   - ç®¡ç†è§„åˆ™çš„åŠ è½½/æŒä¹…åŒ–
 *   - ä» ContextAwarenessService è·å–ä¼ æ„Ÿå™¨æ•°æ®ï¼Œè½¬ä¸º ContextMap
 *   - è°ƒç”¨ C++ evaluateï¼Œè¿”å›æ¨èç»“æœ
 *   - å¤„ç†ç”¨æˆ·åé¦ˆ (MAB reward)
 */
import contextEngine from 'libcontext_engine.so';
import { preferences } from '@kit.ArkData';
import { LogService } from '../../common/LogService';

const TAG = 'ContextEngine';
const log = LogService.getInstance();

// Typed wrappers for native NAPI calls (ArkTS strict mode disallows implicit any)
function nativeLoadRules(json: string): boolean {
  return contextEngine.loadRules(json) as boolean;
}
function nativeAddRule(json: string): boolean {
  return contextEngine.addRule(json) as boolean;
}
function nativeRemoveRule(id: string): boolean {
  return contextEngine.removeRule(id) as boolean;
}
function nativeEvaluate(json: string, max: number): string {
  return contextEngine.evaluate(json, max) as string;
}
function nativeUpdateReward(id: string, reward: number): void {
  contextEngine.updateReward(id, reward);
}
function nativeSelectAction(json: string): number {
  return contextEngine.selectAction(json) as number;
}
function nativeGetStats(): string {
  return contextEngine.getStats() as string;
}
function nativeLoadStats(json: string): void {
  contextEngine.loadStats(json);
}
function nativeGetRuleCount(): number {
  return contextEngine.getRuleCount() as number;
}
function nativeExportRules(): string {
  return contextEngine.exportRules() as string;
}
function nativeExportLinUCB(): string {
  return contextEngine.exportLinUCB() as string;
}
function nativeImportLinUCB(json: string): void {
  contextEngine.importLinUCB(json);
}
function nativePushEvent(json: string): void {
  contextEngine.pushEvent(json);
}
function nativeSetLimits(json: string): void {
  contextEngine.setLimits(json);
}

/** Rule definition for ArkTS side */
export interface ContextRule {
  id: string;
  name: string;
  conditions: ContextCondition[];
  action: ContextAction;
  priority: number;
  cooldownMs: number;
  enabled: boolean;
}

export interface ContextCondition {
  key: string;
  op: string;   // eq, neq, gt, lt, gte, lte, in, range
  value: string;
}

export interface ContextAction {
  id: string;
  type: string;   // suggestion, automation, notification
  payload: string;
}

/** Evaluation result from C++ engine */
export interface MatchResult {
  ruleId: string;
  confidence: number;
  action: ContextAction;
}

/** Context snapshot to pass to engine */
export interface ContextSnapshot {
  timeOfDay: string;       // dawn, morning, afternoon, evening, night
  hour: string;            // "0"-"23"
  dayOfWeek: string;       // "0"-"6" (0=Sunday)
  isWeekend: string;       // "true"/"false"
  motionState: string;     // stationary, walking, running, driving, transit
  batteryLevel: string;    // "0"-"100"
  isCharging: string;      // "true"/"false"
  networkType: string;     // wifi, cellular, none
  geofence?: string;       // current geofence id, if any
  latitude?: string;
  longitude?: string;
  stepCount?: string;
}

/** Minimal geofence info for rule binding (avoids circular import) */
export interface GeofenceBinding {
  id: string;
  category: string;
}

export class ContextEngineService {
  private static instance: ContextEngineService | null = null;
  private initialized: boolean = false;
  private prefsStore: preferences.Preferences | null = null;

  static getInstance(): ContextEngineService {
    if (!ContextEngineService.instance) {
      ContextEngineService.instance = new ContextEngineService();
    }
    return ContextEngineService.instance;
  }

  /** Initialize engine: load persisted rules (builtin + user) and MAB stats */
  async init(context: Context): Promise<void> {
    if (this.initialized) return;

    try {
      this.prefsStore = await preferences.getPreferences(context, 'context_engine');

      // Load persisted rules (builtin from native 'rules' key)
      let rulesJson: string = String(await this.prefsStore.get('rules', '[]'));
      let ok = nativeLoadRules(rulesJson);
      log.info(TAG, `Engine init: loaded ${nativeGetRuleCount()} builtin rules, success=${ok}`);

      // Load user custom rules and add them to the engine
      let userRulesJson: string = String(await this.prefsStore.get('user_rules', '[]'));
      try {
        let userRules: ContextRule[] = JSON.parse(userRulesJson) as ContextRule[];
        for (let i = 0; i < userRules.length; i++) {
          nativeAddRule(JSON.stringify(userRules[i]));
        }
        if (userRules.length > 0) {
          log.info(TAG, `Loaded ${userRules.length} user rules`);
        }
      } catch (e) {
        log.warn(TAG, `Failed to parse user_rules: ${(e as Error).message}`);
      }

      // Load MAB stats
      let statsJson: string = String(await this.prefsStore.get('mab_stats', '{}'));
      nativeLoadStats(statsJson);

      // Load LinUCB state
      let linucbJson: string = String(await this.prefsStore.get('linucb_state', ''));
      if (linucbJson.length > 0) {
        nativeImportLinUCB(linucbJson);
        log.info(TAG, 'LinUCB state restored');
      }

      this.initialized = true;
    } catch (err) {
      let error = err as Error;
      log.system(TAG, `Init failed: ${error.message}`);
    }
  }

  /** Load rules (replaces all). Persists to preferences. */
  async loadRules(rules: ContextRule[]): Promise<boolean> {
    let json = JSON.stringify(rules);
    let ok = nativeLoadRules(json);
    if (ok && this.prefsStore) {
      await this.prefsStore.put('rules', json);
      await this.prefsStore.flush();
    }
    log.info(TAG, `loadRules: ${rules.length} rules, success=${ok}`);
    return ok;
  }

  /** Add or update a single rule. User rules (id starts with 'user_') are persisted separately. */
  async addRule(rule: ContextRule): Promise<boolean> {
    let json = JSON.stringify(rule);
    let ok = nativeAddRule(json);
    if (ok) {
      if (this.isUserRule(rule.id)) {
        await this.persistUserRules();
      }
      await this.persistRules();
    }
    return ok;
  }

  /** Remove a rule by id. Only user rules (id starts with 'user_') can be removed. */
  async removeRule(ruleId: string): Promise<boolean> {
    if (!this.isUserRule(ruleId)) {
      log.warn(TAG, `Cannot remove builtin rule: ${ruleId}`);
      return false;
    }
    let ok = nativeRemoveRule(ruleId);
    if (ok) {
      await this.persistUserRules();
      await this.persistRules();
    }
    return ok;
  }

  /** Check if a rule is user-created (id starts with 'user_') */
  isUserRule(ruleId: string): boolean {
    return ruleId.startsWith('user_');
  }

  /** Toggle a rule's enabled state */
  async toggleRule(ruleId: string, enabled: boolean): Promise<boolean> {
    // Export all rules, find the target, update enabled, re-add
    try {
      let allRulesJson = nativeExportRules();
      let allRules: ContextRule[] = JSON.parse(allRulesJson) as ContextRule[];
      let found = false;
      for (let i = 0; i < allRules.length; i++) {
        if (allRules[i].id === ruleId) {
          allRules[i].enabled = enabled;
          let ok = nativeAddRule(JSON.stringify(allRules[i]));
          if (ok) {
            found = true;
          }
          break;
        }
      }
      if (found) {
        await this.persistRules();
        if (this.isUserRule(ruleId)) {
          await this.persistUserRules();
        }
      }
      return found;
    } catch (e) {
      log.error(TAG, `toggleRule error: ${(e as Error).message}`);
      return false;
    }
  }

  /** Get user-created rules only */
  getUserRules(): ContextRule[] {
    try {
      let allRulesJson = nativeExportRules();
      let allRules: ContextRule[] = JSON.parse(allRulesJson) as ContextRule[];
      let userRules: ContextRule[] = [];
      for (let i = 0; i < allRules.length; i++) {
        if (this.isUserRule(allRules[i].id)) {
          userRules.push(allRules[i]);
        }
      }
      return userRules;
    } catch (e) {
      log.error(TAG, `getUserRules error: ${(e as Error).message}`);
      return [];
    }
  }

  /** Get all rules for display (builtin + user) */
  getAllRulesForDisplay(): ContextRule[] {
    try {
      let allRulesJson = nativeExportRules();
      let allRules: ContextRule[] = JSON.parse(allRulesJson) as ContextRule[];
      return allRules;
    } catch (e) {
      log.error(TAG, `getAllRulesForDisplay error: ${(e as Error).message}`);
      return [];
    }
  }

  /** Evaluate current context and return ranked matches */
  evaluate(snapshot: ContextSnapshot, maxResults: number = 5): MatchResult[] {
    let contextJson = JSON.stringify(snapshot);
    let resultJson = nativeEvaluate(contextJson, maxResults);

    try {
      let parsed: Object = JSON.parse(resultJson);
      let results: MatchResult[] = parsed as MatchResult[];
      return results;
    } catch (err) {
      log.debug(TAG, `evaluate parse error: ${resultJson}`);
      return [];
    }
  }

  /** Record user feedback for MAB + LinUCB learning */
  async feedback(actionId: string, reward: number, snapshot?: ContextSnapshot): Promise<void> {
    if (snapshot) {
      contextEngine.updateReward(actionId, reward, JSON.stringify(snapshot));
    } else {
      nativeUpdateReward(actionId, reward);
    }
    await this.persistStats();
    await this.persistLinUCB();
  }

  /** Action selection from candidates. Uses LinUCB if context provided, MAB fallback otherwise. */
  selectAction(actionIds: string[], snapshot?: ContextSnapshot): number {
    let json = JSON.stringify(actionIds);
    if (snapshot) {
      return contextEngine.selectAction(json, JSON.stringify(snapshot)) as number;
    }
    return nativeSelectAction(json);
  }

  /** Get rule count */
  getRuleCount(): number {
    return nativeGetRuleCount();
  }

  /** Get MAB stats */
  getStats(): string {
    return nativeGetStats();
  }

  /** Export rules as JSON */
  exportRules(): string {
    return nativeExportRules();
  }

  /**
   * Push a context event into the event buffer (for recent/sequence conditions).
   * Call this when notable events happen: geofence enter/exit, motion change, etc.
   */
  pushEvent(eventType: string, context?: ContextSnapshot): void {
    let eventObj: Record<string, Object> = { 'eventType': eventType as Object };
    if (context) {
      eventObj['context'] = context as Object;
    }
    try {
      nativePushEvent(JSON.stringify(eventObj));
    } catch (e) {
      log.error(TAG, `pushEvent failed: ${JSON.stringify(e)}`);
    }
  }

  /**
   * Configure rate limits (category cooldown, global rate limit).
   */
  setLimits(categoryCooldownCount: number, categoryCooldownWindowMs: number, globalMaxPerHour: number): void {
    let limits: Record<string, number> = {
      'categoryCooldownCount': categoryCooldownCount,
      'categoryCooldownWindowMs': categoryCooldownWindowMs,
      'globalMaxPerHour': globalMaxPerHour
    };
    try {
      nativeSetLimits(JSON.stringify(limits));
      log.info(TAG, `Rate limits set: cat=${categoryCooldownCount}/${categoryCooldownWindowMs}ms, global=${globalMaxPerHour}/h`);
    } catch (e) {
      log.error(TAG, `setLimits failed: ${JSON.stringify(e)}`);
    }
  }

  /**
   * å†…ç½®è§„åˆ™æ¨¡æ¿ â€” ç»“æ„å›ºå®šï¼Œgeofence ç±»çš„ value é€šè¿‡ç”¨æˆ·å›´æ è‡ªåŠ¨ç»‘å®š
   *
   * å ä½ç¬¦çº¦å®š:
   *   {{home}}    â†’ ç”¨æˆ·æ ‡è®°ä¸º home ç±»åˆ«çš„ç¬¬ä¸€ä¸ªå›´æ  ID
   *   {{work}}    â†’ ç”¨æˆ·æ ‡è®°ä¸º work ç±»åˆ«çš„ç¬¬ä¸€ä¸ªå›´æ  ID
   *   {{gym}}     â†’ ç”¨æˆ·æ ‡è®°ä¸º gym ç±»åˆ«çš„ç¬¬ä¸€ä¸ªå›´æ  ID
   *
   * å«å ä½ç¬¦çš„è§„åˆ™ï¼šå¦‚æœç”¨æˆ·æ²¡æœ‰å¯¹åº”å›´æ ï¼Œè¯¥è§„åˆ™è‡ªåŠ¨ disabled
   */
  async loadDefaultRules(): Promise<void> {
    // Save user rules before reloading
    let savedUserRules = this.getUserRules();
    let rules = this.getBuiltinRuleTemplates();
    await this.loadRules(rules);
    // Re-add user rules
    for (let i = 0; i < savedUserRules.length; i++) {
      nativeAddRule(JSON.stringify(savedUserRules[i]));
    }
    if (savedUserRules.length > 0) {
      await this.persistRules();
    }
    log.info(TAG, `Loaded ${rules.length} built-in rules + ${savedUserRules.length} user rules`);
  }

  /** å½“ç”¨æˆ·æ·»åŠ /åˆ é™¤å›´æ åè°ƒç”¨ï¼Œé‡æ–°ç»‘å®šè§„åˆ™ä¸­çš„å ä½ç¬¦ï¼ˆä¿ç•™ç”¨æˆ·è§„åˆ™ï¼‰ */
  async rebindGeofences(geofences: GeofenceBinding[]): Promise<void> {
    // Save user rules before reloading builtin templates
    let savedUserRules = this.getUserRules();
    let rules = this.getBuiltinRuleTemplates();

    // æŒ‰ç±»åˆ«æ‰¾åˆ°ç¬¬ä¸€ä¸ªå›´æ  ID
    let homeId = '';
    let workId = '';
    let gymId = '';
    for (let gf of geofences) {
      if (gf.category === 'home' && homeId.length === 0) homeId = gf.id;
      if (gf.category === 'work' && workId.length === 0) workId = gf.id;
      if (gf.category === 'gym' && gymId.length === 0) gymId = gf.id;
    }

    log.info(TAG, `rebindGeofences: home=${homeId} work=${workId} gym=${gymId}`);

    // ç»‘å®šå ä½ç¬¦å¹¶è®¾ç½® enabled
    for (let rule of rules) {
      let needsBinding = false;
      for (let cond of rule.conditions) {
        if (cond.value === '{{home}}') {
          cond.value = homeId;
          if (homeId.length === 0) needsBinding = true;
        } else if (cond.value === '{{work}}') {
          cond.value = workId;
          if (workId.length === 0) needsBinding = true;
        } else if (cond.value === '{{gym}}') {
          cond.value = gymId;
          if (gymId.length === 0) needsBinding = true;
        }
      }
      // ç¼ºå°‘å›´æ ç»‘å®šçš„è§„åˆ™è‡ªåŠ¨ç¦ç”¨
      if (needsBinding) {
        rule.enabled = false;
      }
    }

    await this.loadRules(rules);

    // Re-add user rules
    for (let i = 0; i < savedUserRules.length; i++) {
      nativeAddRule(JSON.stringify(savedUserRules[i]));
    }
    if (savedUserRules.length > 0) {
      await this.persistRules();
    }

    log.info(TAG, `Rules rebound: ${rules.filter(r => r.enabled).length} builtin enabled, ${savedUserRules.length} user rules preserved`);
  }

  private getBuiltinRuleTemplates(): ContextRule[] {
    return [
      // ===== ä¸ä¾èµ–å›´æ çš„é€šç”¨è§„åˆ™ï¼ˆå¼€ç®±å³ç”¨ï¼‰=====
      {
        id: 'rule_morning_workday',
        name: 'å·¥ä½œæ—¥æ—©å‡ºé—¨',
        conditions: [
          { key: 'timeOfDay', op: 'eq', value: 'morning' },
          { key: 'isWeekend', op: 'eq', value: 'false' },
          { key: 'motionState', op: 'in', value: 'walking,driving' }
        ],
        action: { id: 'suggest_morning_commute', type: 'suggestion', payload: 'æ—©ä¸Šå¥½ï¼æŸ¥çœ‹é€šå‹¤è·¯çº¿å’Œå¤©æ°”ï¼Ÿ' },
        priority: 2.0, cooldownMs: 14400000, enabled: true
      },
      {
        id: 'rule_low_battery',
        name: 'ä½ç”µé‡æé†’',
        conditions: [
          { key: 'batteryLevel', op: 'lte', value: '15' },
          { key: 'isCharging', op: 'eq', value: 'false' }
        ],
        action: { id: 'warn_low_battery', type: 'notification', payload: 'ç”µé‡ä¸è¶³ 15%ï¼Œå»ºè®®çœç”µæ¨¡å¼æˆ–å……ç”µ' },
        priority: 3.0, cooldownMs: 1800000, enabled: true
      },
      {
        id: 'rule_weekend_morning',
        name: 'å‘¨æœ«æ—©ä¸Š',
        conditions: [
          { key: 'timeOfDay', op: 'eq', value: 'morning' },
          { key: 'isWeekend', op: 'eq', value: 'true' }
        ],
        action: { id: 'suggest_weekend', type: 'suggestion', payload: 'å‘¨æœ«æ„‰å¿«ï¼çœ‹çœ‹ä»Šå¤©æœ‰ä»€ä¹ˆå¥½ç©çš„ï¼Ÿ' },
        priority: 1.0, cooldownMs: 28800000, enabled: true
      },
      {
        id: 'rule_long_stationary',
        name: 'ä¹…åæé†’',
        conditions: [
          { key: 'motionState', op: 'eq', value: 'stationary' },
          { key: 'timeOfDay', op: 'in', value: 'morning,afternoon' }
        ],
        action: { id: 'suggest_move', type: 'suggestion', payload: 'åäº†å¾ˆä¹…äº†ï¼Œèµ·æ¥æ´»åŠ¨ä¸€ä¸‹å§ ğŸƒ' },
        priority: 1.0, cooldownMs: 5400000, enabled: true
      },
      {
        id: 'rule_commuting',
        name: 'é€šå‹¤è·¯ä¸Š',
        conditions: [
          { key: 'motionState', op: 'in', value: 'driving,transit' },
          { key: 'isWeekend', op: 'eq', value: 'false' },
          { key: 'timeOfDay', op: 'in', value: 'morning,evening' }
        ],
        action: { id: 'suggest_commute_info', type: 'suggestion', payload: 'é€šå‹¤ä¸­ï¼Œè¦å¬æ’­å®¢æˆ–çœ‹æ–°é—»æ‘˜è¦å—ï¼Ÿ' },
        priority: 1.5, cooldownMs: 14400000, enabled: true
      },
      {
        id: 'rule_bedtime',
        name: 'ç¡å‰æé†’',
        conditions: [
          { key: 'hour', op: 'gte', value: '22' },
          { key: 'motionState', op: 'eq', value: 'stationary' }
        ],
        action: { id: 'suggest_bedtime', type: 'suggestion', payload: 'å¤œæ·±äº†ï¼Œæ˜å¤©çš„æ—¥ç¨‹å·²å‡†å¤‡å¥½ï¼Œæ—©ç‚¹ä¼‘æ¯ ğŸŒ™' },
        priority: 1.0, cooldownMs: 28800000, enabled: true
      },

      // ===== ä¾èµ–å›´æ çš„è§„åˆ™ï¼ˆè‡ªåŠ¨ç»‘å®šï¼Œç¼ºå›´æ åˆ™ç¦ç”¨ï¼‰=====
      {
        id: 'rule_evening_home',
        name: 'åˆ°å®¶æ”¾æ¾',
        conditions: [
          { key: 'timeOfDay', op: 'eq', value: 'evening' },
          { key: 'geofence', op: 'eq', value: '{{home}}' },
          { key: 'motionState', op: 'eq', value: 'stationary' }
        ],
        action: { id: 'suggest_evening_relax', type: 'suggestion', payload: 'åˆ°å®¶äº†ï¼å¬éŸ³ä¹æˆ–çœ‹æ–°é—»æ‘˜è¦ï¼Ÿ' },
        priority: 1.5, cooldownMs: 14400000, enabled: true
      },
      {
        id: 'rule_leave_home_morning',
        name: 'æ—©ä¸Šç¦»å®¶',
        conditions: [
          { key: 'timeOfDay', op: 'eq', value: 'morning' },
          { key: 'geofence', op: 'neq', value: '{{home}}' },
          { key: 'motionState', op: 'in', value: 'walking,driving' }
        ],
        action: { id: 'suggest_morning_brief', type: 'suggestion', payload: 'å‡ºé—¨äº†ï¼ä»Šæ—¥å¤©æ°”å’Œæ—¥ç¨‹æ¦‚è§ˆï¼Ÿ' },
        priority: 2.0, cooldownMs: 14400000, enabled: true
      },
      {
        id: 'rule_arrive_work',
        name: 'åˆ°è¾¾å…¬å¸',
        conditions: [
          { key: 'geofence', op: 'eq', value: '{{work}}' },
          { key: 'isWeekend', op: 'eq', value: 'false' },
          { key: 'motionState', op: 'eq', value: 'stationary' }
        ],
        action: { id: 'suggest_work_mode', type: 'suggestion', payload: 'åˆ°å…¬å¸äº†ï¼Œå¼€å¯å·¥ä½œæ¨¡å¼ï¼ŸæŸ¥çœ‹ä»Šæ—¥å¾…åŠ' },
        priority: 2.0, cooldownMs: 28800000, enabled: true
      },
      {
        id: 'rule_leave_work',
        name: 'ä¸‹ç­ç¦»å¼€å…¬å¸',
        conditions: [
          { key: 'geofence', op: 'neq', value: '{{work}}' },
          { key: 'timeOfDay', op: 'in', value: 'evening,night' },
          { key: 'isWeekend', op: 'eq', value: 'false' }
        ],
        action: { id: 'suggest_leave_work', type: 'suggestion', payload: 'ä¸‹ç­äº†ï¼æŸ¥çœ‹å›å®¶è·¯çº¿ï¼Ÿ' },
        priority: 1.5, cooldownMs: 28800000, enabled: true
      },
      {
        id: 'rule_leave_work_music',
        name: 'ç¦»å¼€å…¬å¸æ­¥è¡Œå¬éŸ³ä¹',
        conditions: [
          { key: 'geofence', op: 'neq', value: '{{work}}' },
          { key: 'motionState', op: 'eq', value: 'walking' },
          { key: 'isWeekend', op: 'eq', value: 'false' }
        ],
        action: { id: 'suggest_music', type: 'suggestion', payload: 'èµ°è·¯ä¸­ ğŸµ æ‰“å¼€éŸ³ä¹æ”¾æ¾ä¸€ä¸‹ï¼Ÿ' },
        priority: 2.0, cooldownMs: 28800000, enabled: true
      },
      {
        id: 'rule_arrive_gym',
        name: 'åˆ°è¾¾å¥èº«æˆ¿',
        conditions: [
          { key: 'geofence', op: 'eq', value: '{{gym}}' }
        ],
        action: { id: 'suggest_workout', type: 'suggestion', payload: 'åˆ°å¥èº«æˆ¿äº†ğŸ’ª å¼€å§‹ä»Šå¤©çš„è®­ç»ƒè®¡åˆ’ï¼Ÿ' },
        priority: 1.5, cooldownMs: 14400000, enabled: true
      }
    ];
  }

  private async persistRules(): Promise<void> {
    if (!this.prefsStore) return;
    let json = nativeExportRules();
    await this.prefsStore.put('rules', json);
    await this.prefsStore.flush();
  }

  /** Persist only user rules to a separate preferences key */
  private async persistUserRules(): Promise<void> {
    if (!this.prefsStore) return;
    let userRules = this.getUserRules();
    await this.prefsStore.put('user_rules', JSON.stringify(userRules));
    await this.prefsStore.flush();
    log.info(TAG, `Persisted ${userRules.length} user rules`);
  }

  private async persistStats(): Promise<void> {
    if (!this.prefsStore) return;
    let json = nativeGetStats();
    await this.prefsStore.put('mab_stats', json);
    await this.prefsStore.flush();
  }

  private async persistLinUCB(): Promise<void> {
    if (!this.prefsStore) return;
    let json = nativeExportLinUCB();
    await this.prefsStore.put('linucb_state', json);
    await this.prefsStore.flush();
  }
}
