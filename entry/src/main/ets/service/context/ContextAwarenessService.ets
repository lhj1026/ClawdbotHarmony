/**
 * Context Awareness Service
 * 
 * æ ¸å¿ƒæœåŠ¡ï¼šæ•´åˆä¼ æ„Ÿå™¨ã€åœ°ç†å›´æ ã€è¡Œä¸ºè®°å½•å’Œæ¨è
 */
import { sensor } from '@kit.SensorServiceKit';
import { batteryInfo } from '@kit.BasicServicesKit';
import { wifiManager } from '@kit.ConnectivityKit';
import { common, abilityAccessCtrl } from '@kit.AbilityKit';
import { preferences } from '@kit.ArkData';
import { LogService } from '../../common/LogService';
import { Constants } from '../../common/Constants';
import { GeofenceManager, GeofenceEvent } from './GeofenceManager';
import { BehaviorLogger } from './BehaviorLogger';
import { ContextEngineService, ContextSnapshot, ContextRule as EngineRule, ContextCondition as EngineCondition, ContextAction as EngineAction, MatchResult, GeofenceBinding } from './ContextEngine';
import { LocationDiscoveryService, GeofenceSuggestion, DiscoveryStatsInfo } from './LocationDiscoveryService';
import { FeedbackService } from './FeedbackService';
import { LocationFusionService, LearnedSignalsSummary } from './LocationFusionService';
import { DigitalWorldService } from './DigitalWorldService';
import DataTray, { DataTray as SensorDataTray, TrayStatus } from './DataTray';
import {
  EnvironmentContext,
  MotionState,
  TimeOfDay,
  NetworkType,
  UserAction,
  ActionOutcome,
  ContextRule,
  RuleTrigger,
  Geofence,
  LocationState,
  FeedbackStats,
  LLMRecommendation,
  GeofenceCategory,
} from './ContextModels';
import { LLMFallbackService } from './LLMFallbackService';

const TAG = 'ContextService';

export interface ContextRecommendation {
  rule: ContextRule;
  action: UserAction;
  reason: string;
}

type RecommendationListener = (rec: ContextRecommendation) => void;
type SuggestionListener = (suggestions: GeofenceSuggestion[]) => void;

/** Persisted state for geofence suggestion filtering */
interface GeofenceSuggestionState {
  /** Cluster IDs the user permanently ignored */
  blacklist: string[];
  /** Cluster ID â†’ timestamp when deferred ("ä»¥åå†è¯´"), resurface after 7 days */
  deferred: Record<string, number>;
  /** Cluster ID â†’ timestamp of last suggestion shown, max once per day */
  lastShown: Record<string, number>;
}

const SUGGEST_PREFS_KEY = 'geofence_suggestion_state';
const DEFER_DURATION_MS = 7 * 24 * 3600 * 1000;     // 7 days
const DAILY_COOLDOWN_MS = 24 * 3600 * 1000;          // 24 hours

/** åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨æ•°æ®æ¥å£ */
interface AccelerometerData {
  x: number;
  y: number;
  z: number;
}

export class ContextAwarenessService {
  private static instance: ContextAwarenessService;
  private log: LogService = LogService.getInstance();
  
  private geofenceMgr: GeofenceManager;
  private behaviorLog: BehaviorLogger;
  private feedbackSvc: FeedbackService;
  
  private initialized: boolean = false;
  private isRunning: boolean = false;
  private context: common.UIAbilityContext | undefined;
  
  // å½“å‰çŠ¶æ€
  private currentContext: EnvironmentContext | undefined;
  private lastLocation: LocationState | undefined;
  private lastMotionState: MotionState = 'unknown';
  
  // ä¼ æ„Ÿå™¨æ•°æ®
  private accelerometerData: AccelerometerData = { x: 0, y: 0, z: 0 } as AccelerometerData;
  private stepCount: number = 0;
  
  // WiFi çŠ¶æ€è·Ÿè¸ª
  private lastWifiSsid: string = '';
  private wifiLostWorkTimestamp: number = 0;  // backward compat
  private wifiLostTimestamps: Map<string, number> = new Map();  // category â†’ timestamp
  private static readonly WIFI_LOST_TTL_MS = 10 * 60 * 1000;  // WiFiä¸¢å¤±æ ‡è®°ä¿æŒ10åˆ†é’Ÿ
  
  // æ¨èç›‘å¬å™¨
  private recommendationListeners: RecommendationListener[] = [];
  
  // C++ è§„åˆ™å¼•æ“
  private engine: ContextEngineService = ContextEngineService.getInstance();
  private evaluationTimer: number = -1;
  private static readonly EVALUATION_INTERVAL_MS = 2 * 60 * 1000;  // 2åˆ†é’Ÿè¯„ä¼°ä¸€æ¬¡
  
  // é˜²æŠ–ï¼šé¿å…é‡å¤æ¨è
  private lastRecommendations: Map<string, number> = new Map();
  private static readonly RECOMMENDATION_COOLDOWN_MS = 5 * 60 * 1000;  // 5åˆ†é’Ÿå†·å´
  
  // ä½ç½®è‡ªåŠ¨å‘ç°
  private locationDiscovery: LocationDiscoveryService = LocationDiscoveryService.getInstance();
  private discoveryTimer: number = -1;
  private static readonly DISCOVERY_INTERVAL_MS = 60 * 60 * 1000;  // 1å°æ—¶å‘ç°ä¸€æ¬¡

  // LLM å…œåº•æœåŠ¡
  private llmFallback: LLMFallbackService = LLMFallbackService.getInstance();
  // å¤šæºä½ç½®èåˆ
  private locationFusion: LocationFusionService = LocationFusionService.getInstance();
  // å›´æ å»ºè®®ç®¡ç†
  private suggestionListeners: SuggestionListener[] = [];
  private suggestionState: GeofenceSuggestionState = { blacklist: [], deferred: {}, lastShown: {} };
  private suggestionStateLoaded: boolean = false;
  // æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
  private digitalWorld: DigitalWorldService = DigitalWorldService.getInstance();
  // ä¼ æ„Ÿå™¨æ•°æ®æ‰˜ç›˜
  private tray: SensorDataTray = DataTray;

  private constructor() {
    this.geofenceMgr = GeofenceManager.getInstance();
    this.behaviorLog = BehaviorLogger.getInstance();
    this.feedbackSvc = FeedbackService.getInstance();
  }
  
  static getInstance(): ContextAwarenessService {
    if (!ContextAwarenessService.instance) {
      ContextAwarenessService.instance = new ContextAwarenessService();
    }
    return ContextAwarenessService.instance;
  }
  
  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = context;
    
    await this.geofenceMgr.init(context);
    await this.behaviorLog.init(context);
    
    // åˆå§‹åŒ– C++ è§„åˆ™å¼•æ“
    await this.engine.init(context);
    if (this.engine.getRuleCount() === 0) {
      await this.engine.loadDefaultRules();
      this.log.info(TAG, `Loaded default rules: ${this.engine.getRuleCount()}`);
    }
    
    // åˆå§‹åŒ–å¤šæºä½ç½®èåˆ
    await this.locationFusion.init(context);

    // åˆå§‹åŒ–ä½ç½®å‘ç°æœåŠ¡
    await this.locationDiscovery.init(context);
    await this.feedbackSvc.init(context);
    await this.loadSuggestionState();

    // åˆå§‹åŒ– LLM å…œåº•æœåŠ¡
    this.llmFallback.init(context);

    // åˆå§‹åŒ–æ•°å­—ä¸–ç•Œæ„ŸçŸ¥æœåŠ¡
    // TODO [Digital World Integration]: DigitalWorldService provides digital context
    // (calendar events, screen state, audio scene, etc.) that enriches the ContextSnapshot.
    // Currently initialized and polled independently; data is merged in buildSnapshot().
    await this.digitalWorld.init(context);

    // ç›‘å¬åœ°ç†å›´æ äº‹ä»¶
    this.geofenceMgr.addListener((event) => this.onGeofenceEvent(event));

    this.initialized = true;
    this.log.info(TAG, `Context Awareness Service initialized, rules: ${this.engine.getRuleCount()}`);
  }
  
  
  async start(): Promise<boolean> {
    if (this.isRunning) return true;
    if (!this.initialized) {
      this.log.error(TAG, 'Service not initialized');
      return false;
    }
    
    try {
      // å¯åŠ¨ä½ç½®ç›‘æ§
      await this.geofenceMgr.startMonitoring();
      
      // è¯·æ±‚è¿åŠ¨ä¼ æ„Ÿå™¨æƒé™å¹¶å¯åŠ¨
      await this.requestMotionPermission();
      this.startMotionSensors();
      
      // å¯åŠ¨ WiFi çŠ¶æ€ç›‘å¬
      this.startWifiMonitoring();
      
      // å¯åŠ¨å®šæ—¶è§„åˆ™è¯„ä¼°
      this.startPeriodicEvaluation();

      // å¯åŠ¨ä½ç½®è‡ªåŠ¨å‘ç°ï¼ˆå®šæ—¶èšç±»ï¼‰
      this.startLocationDiscovery();

      // å¯åŠ¨æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
      this.digitalWorld.start();

      this.isRunning = true;
      this.log.info(TAG, 'Context Awareness Service started');
      return true;
    } catch (err) {
      this.log.error(TAG, `Failed to start: ${(err as Error).message}`);
      return false;
    }
  }
  
  stop(): void {
    if (!this.isRunning) return;
    
    this.geofenceMgr.stopMonitoring();
    this.stopMotionSensors();
    this.stopWifiMonitoring();
    this.stopPeriodicEvaluation();
    this.stopLocationDiscovery();
    this.digitalWorld.stop();

    this.isRunning = false;
    this.log.info(TAG, 'Context Awareness Service stopped');
  }
  
  
  // ==================== WiFi çŠ¶æ€ç›‘å¬ ====================
  
  private wifiConnectionCallback: ((state: number) => void) | undefined;
  
  private startWifiMonitoring(): void {
    try {
      this.wifiConnectionCallback = (state: number) => {
        // state: 0=disconnected, 1=connected
        if (state === 0) {
          this.onWifiDisconnected();
        } else if (state === 1) {
          this.onWifiConnected();
        }
      };
      wifiManager.on('wifiConnectionChange', this.wifiConnectionCallback);
      this.log.info(TAG, 'WiFi monitoring started');
    } catch (err) {
      this.log.warn(TAG, `WiFi monitoring failed: ${(err as Error).message}`);
    }
  }
  
  private stopWifiMonitoring(): void {
    try {
      if (this.wifiConnectionCallback) {
        wifiManager.off('wifiConnectionChange', this.wifiConnectionCallback);
        this.wifiConnectionCallback = undefined;
      }
    } catch { /* ignore */ }
  }
  
  private onWifiDisconnected(): void {
    let lostSsid = this.lastWifiSsid;
    this.log.info(TAG, `WiFi disconnected, last SSID: ${lostSsid}`);

    if (lostSsid.length === 0) return;

    // éå†æ‰€æœ‰å›´æ ï¼Œæ£€æŸ¥ä¸¢å¤±çš„ WiFi æ˜¯å¦åŒ¹é…ä»»ä½•å›´æ çš„å­¦ä¹ ä¿¡å·
    let allGeofences = this.geofenceMgr.getAllGeofences();
    let matchedCategory = '';

    for (let gf of allGeofences) {
      let summary = this.locationFusion.getLearnedSignalsSummary(gf);
      if (summary && summary.wifiSsids.includes(lostSsid)) {
        matchedCategory = gf.category;
        break;
      }
    }

    if (matchedCategory.length > 0) {
      let now = Date.now();
      this.log.info(TAG, `WiFi lost: ${lostSsid} â€” leaving ${matchedCategory} geofence`);
      this.wifiLostTimestamps.set(matchedCategory, now);

      // è®¾ç½®é€šç”¨ä¸¢å¤±æ ‡è®°
      this.tray.put('wifiLost', 'true', 0.8, 'wifi');
      this.tray.put('wifiLostCategory', matchedCategory, 0.8, 'wifi');

      // å‘åå…¼å®¹ï¼šwork ç±»åˆ«åŒæ—¶è®¾ç½® wifiLostWork
      if (matchedCategory === 'work') {
        this.wifiLostWorkTimestamp = now;
        this.tray.put('wifiLostWork', 'true', 0.8, 'wifi');
      }

      this.engine.pushEvent('wifi_lost_' + matchedCategory);

      // ç«‹å³è§¦å‘è¯„ä¼°
      this.refreshTray().then(() => {
        let snapshot = this.augmentSnapshot(this.tray.getSnapshot());
        this.evaluateAndDeliver(snapshot);
      });
    }

    // æ¸…é™¤å½“å‰ WiFi å›´æ åŒ¹é…
    this.tray.put('wifiGeofence', '', 0, 'wifi');
    this.lastWifiSsid = '';
  }
  
  private onWifiConnected(): void {
    // WiFi é‡æ–°è¿æ¥ï¼Œæ¸…é™¤ä¸¢å¤±æ ‡è®°
    this.wifiLostWorkTimestamp = 0;
    this.wifiLostTimestamps.clear();

    // å°è¯•è·å–å½“å‰ SSID å¹¶åŒ¹é…å›´æ 
    try {
      wifiManager.getLinkedInfo().then((info) => {
        let ssid = info.ssid || '';
        if (ssid.startsWith('"') && ssid.endsWith('"')) {
          ssid = ssid.substring(1, ssid.length - 1);
        }
        if (ssid.length === 0) return;

        this.lastWifiSsid = ssid;
        this.tray.put('wifiSsid', ssid, 1.0, 'wifi');

        // éå†æ‰€æœ‰å›´æ æŸ¥æ‰¾åŒ¹é…
        let allGeofences = this.geofenceMgr.getAllGeofences();
        for (let gf of allGeofences) {
          let summary = this.locationFusion.getLearnedSignalsSummary(gf);
          if (summary && summary.wifiSsids.includes(ssid)) {
            this.log.info(TAG, `WiFi connected: ${ssid} matches ${gf.category} geofence`);
            this.tray.put('wifiGeofence', gf.category, 0.9, 'wifi');
            this.engine.pushEvent('wifi_arrive_' + gf.category);

            // ç«‹å³è§¦å‘è¯„ä¼°
            this.refreshTray().then(() => {
              let snapshot = this.augmentSnapshot(this.tray.getSnapshot());
              this.evaluateAndDeliver(snapshot);
            });
            return;
          }
        }
      });
    } catch (err) {
      this.log.debug(TAG, `WiFi connected, get info failed: ${(err as Error).message}`);
    }
  }
  
  /**
   * å¢å¼º snapshotï¼šè¡¥å…… WiFi å›´æ ä¸¢å¤±æ ‡è®°ï¼ˆåŸºäº wifiLostTimestamps çš„ TTLï¼‰
   */
  private augmentSnapshot(snapshot: ContextSnapshot): ContextSnapshot {
    let now = Date.now();
    // æ£€æŸ¥æ‰€æœ‰ WiFi ä¸¢å¤±æ—¶é—´æˆ³ï¼Œæ‰¾æœ€è¿‘çš„æœªè¿‡æœŸè®°å½•
    let latestCategory = '';
    let latestTime = 0;
    this.wifiLostTimestamps.forEach((ts: number, category: string) => {
      if (now - ts < ContextAwarenessService.WIFI_LOST_TTL_MS && ts > latestTime) {
        latestCategory = category;
        latestTime = ts;
      }
    });
    if (latestCategory.length > 0) {
      snapshot.wifiLost = 'true';
      snapshot.wifiLostCategory = latestCategory;
      if (latestCategory === 'work') {
        snapshot.wifiLostWork = 'true';
      }
    }
    return snapshot;
  }

  private async requestMotionPermission(): Promise<boolean> {
    try {
      let atManager = abilityAccessCtrl.createAtManager();
      let result = await atManager.requestPermissionsFromUser(this.context as common.UIAbilityContext,
        ['ohos.permission.ACTIVITY_MOTION']);
      let granted = result.authResults[0] === 0;
      this.log.info(TAG, `ACTIVITY_MOTION permission: ${granted ? 'granted' : 'denied'}`);
      return granted;
    } catch (err) {
      this.log.warn(TAG, `Motion permission request failed: ${(err as Error).message}`);
      return false;
    }
  }

  private startMotionSensors(): void {
    try {
      // åŠ é€Ÿåº¦è®¡ - ç”¨äºè¿åŠ¨çŠ¶æ€æ£€æµ‹
      sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {
        this.accelerometerData = { x: data.x, y: data.y, z: data.z } as AccelerometerData;
        this.updateMotionState();
      }, { interval: 1000000000 });  // 1ç§’é‡‡æ ·
      
      // è®¡æ­¥å™¨
      sensor.on(sensor.SensorId.PEDOMETER, (data: sensor.PedometerResponse) => {
        this.stepCount = data.steps;
        this.tray.put('stepCount', data.steps.toString(), 1.0, 'pedometer');
      }, { interval: 5000000000 });  // 5ç§’é‡‡æ ·
      
      this.log.info(TAG, 'Motion sensors started');
    } catch (err) {
      this.log.warn(TAG, `Sensor error: ${(err as Error).message}`);
    }
  }
  
  private stopMotionSensors(): void {
    try {
      sensor.off(sensor.SensorId.ACCELEROMETER);
      sensor.off(sensor.SensorId.PEDOMETER);
    } catch {
      // ignore
    }
  }
  
  /**
   * åŸºäºåŠ é€Ÿåº¦è®¡æ•°æ®åˆ¤æ–­è¿åŠ¨çŠ¶æ€
   * ç®€åŒ–ç‰ˆæœ¬ï¼šä½¿ç”¨åŠ é€Ÿåº¦å¹…åº¦
   */
  private updateMotionState(): void {
    let x = this.accelerometerData.x;
    let y = this.accelerometerData.y;
    let z = this.accelerometerData.z;
    let magnitude = Math.sqrt(x * x + y * y + z * z);
    
    // ç®€å•é˜ˆå€¼åˆ¤æ–­ï¼ˆå®é™…åº”ç”¨éœ€è¦æ›´å¤æ‚çš„ç®—æ³•ï¼‰
    let newState: MotionState;
    
    if (magnitude < 10.5) {
      newState = 'stationary';
    } else if (magnitude < 12) {
      newState = 'walking';
    } else if (magnitude < 15) {
      newState = 'running';
    } else {
      // é«˜åŠ é€Ÿåº¦å¯èƒ½æ˜¯è½¦è¾†
      newState = this.lastLocation?.speed && this.lastLocation.speed > 5 ? 'driving' : 'walking';
    }
    
    // Always update tray with latest motion data
    this.tray.put('motionState', newState, 0.9, 'accelerometer');

    if (newState !== this.lastMotionState) {
      this.log.debug(TAG, `Motion state: ${this.lastMotionState} -> ${newState}`);
      this.engine.pushEvent('motion_' + newState);
      this.lastMotionState = newState;
    }
  }


  private startPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) return;
    this.evaluationTimer = setInterval(() => {
      this.periodicEvaluate();
    }, ContextAwarenessService.EVALUATION_INTERVAL_MS);
    this.log.info(TAG, 'Started periodic evaluation');
  }

  private stopPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) {
      clearInterval(this.evaluationTimer);
      this.evaluationTimer = -1;
      this.log.info(TAG, 'Stopped periodic evaluation');
    }
  }

  private async periodicEvaluate(): Promise<void> {
    if (!this.isRunning) return;
    // Refresh tray with latest sensor data, then read snapshot from tray
    await this.refreshTray();
    let snapshot = this.tray.getSnapshot();
    await this.evaluateAndDeliver(snapshot);
  }


  private startLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) return;

    // ç›‘å¬ä½ç½®å˜åŒ–ï¼Œè®°å½•åˆ°å‘ç°æœåŠ¡
    this.geofenceMgr.addLocationListener((location) => {
      this.locationDiscovery.recordLocation(location);
    });

    // å®šæ—¶è¿è¡Œèšç±»å‘ç°
    this.discoveryTimer = setInterval(() => {
      this.runLocationDiscovery();
    }, ContextAwarenessService.DISCOVERY_INTERVAL_MS);

    this.log.info(TAG, 'Started location discovery');
  }

  private stopLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) {
      clearInterval(this.discoveryTimer);
      this.discoveryTimer = -1;
      this.log.info(TAG, 'Stopped location discovery');
    }
  }

  private async runLocationDiscovery(): Promise<void> {
    if (!this.isRunning) return;
    let allSuggestions = await this.locationDiscovery.runDiscovery();
    if (allSuggestions.length === 0) return;

    let filtered = this.filterSuggestions(allSuggestions);
    if (filtered.length === 0) {
      this.log.info(TAG, `Discovery found ${allSuggestions.length} raw, all filtered out`);
      return;
    }

    // Mark as shown today
    let now = Date.now();
    for (let i = 0; i < filtered.length; i++) {
      this.suggestionState.lastShown[filtered[i].id] = now;
    }
    this.saveSuggestionState();

    this.log.info(TAG, `Emitting ${filtered.length} geofence suggestions`);
    this.notifySuggestionListeners(filtered);
  }

  /** è·å–ä½ç½®å‘ç°å»ºè®® */
  getLocationSuggestions(): GeofenceSuggestion[] {
    return this.locationDiscovery.getSuggestions();
  }

  /** è·å–ä½ç½®å‘ç°ç»Ÿè®¡ */
  getLocationDiscoveryStats(): DiscoveryStatsInfo {
    return this.locationDiscovery.getStats();
  }

  
  /**
   * åˆ·æ–°æ‰˜ç›˜ï¼šå°†æ‰€æœ‰å¯è½®è¯¢çš„ä¼ æ„Ÿå™¨æ•°æ®å†™å…¥æ‰˜ç›˜
   * äº‹ä»¶é©±åŠ¨çš„æ•°æ®ï¼ˆåŠ é€Ÿåº¦è®¡ã€å›´æ ï¼‰ç”±å›è°ƒç›´æ¥å†™å…¥ã€‚
   */
  private async refreshTray(): Promise<void> {
    let now = new Date();
    let hour = now.getHours();

    // æ—¶é—´ï¼ˆå®æ—¶è®¡ç®—ï¼ŒTTL=âˆï¼‰
    let timeOfDay: TimeOfDay;
    if (hour >= 5 && hour < 12) timeOfDay = 'morning';
    else if (hour >= 12 && hour < 17) timeOfDay = 'afternoon';
    else if (hour >= 17 && hour < 21) timeOfDay = 'evening';
    else timeOfDay = 'night';

    let dayOfWeek = now.getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

    this.tray.put('hour', hour.toString(), 1.0, 'system');
    this.tray.put('timeOfDay', timeOfDay, 1.0, 'system');
    this.tray.put('dayOfWeek', dayOfWeek.toString(), 1.0, 'system');
    this.tray.put('isWeekend', isWeekend ? 'true' : 'false', 1.0, 'system');

    // ç”µæ± 
    try {
      this.tray.put('batteryLevel', batteryInfo.batterySOC.toString(), 1.0, 'battery');
      let charging = batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE;
      this.tray.put('isCharging', charging ? 'true' : 'false', 1.0, 'battery');
    } catch {
      // ignore
    }

    // ç½‘ç»œ + WiFi SSID
    try {
      if (wifiManager.isWifiActive()) {
        this.tray.put('networkType', 'wifi', 1.0, 'wifi');
        try {
          let info = await wifiManager.getLinkedInfo();
          let ssid = info.ssid || '';
          if (ssid.startsWith('"') && ssid.endsWith('"')) {
            ssid = ssid.substring(1, ssid.length - 1);
          }
          if (ssid.length > 0) {
            this.tray.put('wifiSsid', ssid, 1.0, 'wifi');
            this.lastWifiSsid = ssid;
          }
        } catch { /* ignore */ }
      } else {
        this.tray.put('networkType', 'cellular', 0.8, 'network');
      }
    } catch {
      // ignore
    }
    
    // WiFiä¸¢å¤±æ ‡è®°ï¼ˆéå†æ‰€æœ‰ç±»åˆ«ï¼Œæœ‰æ•ˆæœŸå†…ï¼‰
    let nowMs = Date.now();
    this.wifiLostTimestamps.forEach((ts: number, category: string) => {
      if (nowMs - ts < ContextAwarenessService.WIFI_LOST_TTL_MS) {
        this.tray.put('wifiLost', 'true', 0.8, 'wifi');
        this.tray.put('wifiLostCategory', category, 0.8, 'wifi');
        // å‘åå…¼å®¹
        if (category === 'work') {
          this.tray.put('wifiLostWork', 'true', 0.8, 'wifi');
        }
      }
    });

    // ä½ç½® / å›´æ 
    if (this.lastLocation) {
      this.tray.put('latitude', this.lastLocation.latitude.toString(), 1.0, 'gps');
      this.tray.put('longitude', this.lastLocation.longitude.toString(), 1.0, 'gps');

      let geofences = this.geofenceMgr.getGeofencesAtLocation(
        this.lastLocation.latitude,
        this.lastLocation.longitude
      );
      if (geofences.length > 0) {
        this.tray.put('geofence', geofences[0].id, 1.0, 'geofence');
      }
    }

    // æ­¥æ•°
    if (this.stepCount > 0) {
      this.tray.put('stepCount', this.stepCount.toString(), 1.0, 'pedometer');
    }

    // è¿åŠ¨çŠ¶æ€ï¼ˆåŠ é€Ÿåº¦è®¡å›è°ƒå·²å†™å…¥ï¼Œè¿™é‡Œç¡®ä¿æœ‰å€¼ï¼‰
    if (this.lastMotionState !== 'unknown') {
      this.tray.put('motionState', this.lastMotionState, 0.9, 'accelerometer');
    }
  }

  /**
   * è·å–å½“å‰å®Œæ•´çš„ç¯å¢ƒä¸Šä¸‹æ–‡
   * ä¿ç•™ä¾›åé¦ˆè·¯å¾„å’Œå…¼å®¹æ—§ API ä½¿ç”¨ã€‚å†…éƒ¨åŒæ—¶åˆ·æ–°æ‰˜ç›˜ã€‚
   */
  async getCurrentContext(): Promise<EnvironmentContext> {
    // åˆ·æ–°æ‰˜ç›˜ï¼ˆæ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®å†™å…¥ï¼‰
    await this.refreshTray();

    let now = new Date();
    let hour = now.getHours();

    let timeOfDay: TimeOfDay;
    if (hour >= 5 && hour < 12) timeOfDay = 'morning';
    else if (hour >= 12 && hour < 17) timeOfDay = 'afternoon';
    else if (hour >= 17 && hour < 21) timeOfDay = 'evening';
    else timeOfDay = 'night';

    let dayOfWeek = now.getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

    // è®¾å¤‡çŠ¶æ€
    let batteryLevel = 100;
    let isCharging = false;
    try {
      batteryLevel = batteryInfo.batterySOC;
      isCharging = batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE;
    } catch {
      // ignore
    }

    // ç½‘ç»œçŠ¶æ€
    let networkType: NetworkType = 'none';
    try {
      if (wifiManager.isWifiActive()) {
        networkType = 'wifi';
      } else {
        networkType = 'cellular';
      }
    } catch {
      // ignore
    }
    
    // å½“å‰å›´æ ï¼ˆå¤šæºèåˆï¼‰

    // å½“å‰å›´æ 
    let currentGeofence: Geofence | undefined;
    let allGeofences = this.geofenceMgr.getAllGeofences();
    let fusionResult = await this.locationFusion.getBestMatch(allGeofences, this.lastLocation);
    if (fusionResult) {
      currentGeofence = this.geofenceMgr.getGeofence(fusionResult.geofenceId);
      this.log.debug(TAG,
        `Fused location: ${fusionResult.geofenceId} conf=${fusionResult.confidence.toFixed(2)} src=${fusionResult.source}`);
    } else if (this.lastLocation) {
      // é™çº§ï¼šèåˆæ— ç»“æœæ—¶ç”¨åŸå§‹ GPS
      let gpsGeofences = this.geofenceMgr.getGeofencesAtLocation(
        this.lastLocation.latitude,
        this.lastLocation.longitude
      );
      currentGeofence = gpsGeofences[0];
    }

    let ctx: EnvironmentContext = {
      timestamp: Date.now(),
      location: this.lastLocation,
      currentGeofence,
      motionState: this.lastMotionState,
      stepCount: this.stepCount,
      timeOfDay,
      dayOfWeek,
      isWeekend,
      batteryLevel,
      isCharging,
      networkType,
      screenOn: true,
    };

    this.currentContext = ctx;
    return ctx;
  }

  /**
   * æ„å»º C++ è§„åˆ™å¼•æ“éœ€è¦çš„å¿«ç…§æ ¼å¼
   *
   * TODO [Digital World Integration Point]:
   * Digital world data from DigitalWorldService is merged into the snapshot here.
   * The C++ engine's ContextSnapshot currently uses a fixed set of keys (timeOfDay,
   * hour, motionState, etc.), but the evaluate() method passes JSON so additional
   * digital-world keys (cal_hasUpcoming, audio_inCall, screen_locked, etc.) can be
   * matched by rules that reference these keys. New rules can use conditions like:
   *   { key: 'cal_inMeeting', op: 'eq', value: 'true' }
   *   { key: 'audio_inCall', op: 'eq', value: 'true' }
   *   { key: 'screen_locked', op: 'eq', value: 'true' }
   *
   * To fully wire this up:
   * 1. Extend ContextSnapshot interface in ContextEngine.ets with optional digital fields
   * 2. Add built-in rules that reference digital-world keys
   * 3. Connect DigitalWorldService lifecycle to this service (done â€” see init/start/stop)
   */
  private buildSnapshot(ctx: EnvironmentContext): ContextSnapshot {
    let now = new Date();
    let hour = now.getHours();
    let dayOfWeek = now.getDay();

    let snapshot: ContextSnapshot = {
      timeOfDay: ctx.timeOfDay,
      hour: hour.toString(),
      dayOfWeek: dayOfWeek.toString(),
      isWeekend: ctx.isWeekend ? 'true' : 'false',
      motionState: ctx.motionState || 'unknown',
      batteryLevel: ctx.batteryLevel.toString(),
      isCharging: ctx.isCharging ? 'true' : 'false',
      networkType: ctx.networkType || 'none',
      geofence: ctx.currentGeofence?.id,
      latitude: ctx.location?.latitude?.toString(),
      longitude: ctx.location?.longitude?.toString(),
      stepCount: ctx.stepCount?.toString()
    };

    // TODO [Digital World Integration]: Merge digital world data into snapshot.
    // When ContextSnapshot interface is extended with an index signature or
    // digital-specific fields, uncomment the following to enrich the snapshot:
    //
    // let digitalData = this.digitalWorld.getDigitalData();
    // let digitalKeys = Object.keys(digitalData);
    // for (let i = 0; i < digitalKeys.length; i++) {
    //   (snapshot as Record<string, string | undefined>)[digitalKeys[i]] = digitalData[digitalKeys[i]];
    // }

    return snapshot;
  }

  /**
   * è¯„ä¼°å¹¶æ¨é€æ¨èï¼Œæ— åŒ¹é…æ—¶è°ƒç”¨ LLM å…œåº•
   * è¯„ä¼°å¹¶æ¨é€æ¨è
   */
  private async evaluateAndDeliver(snapshot: ContextSnapshot): Promise<void> {
    let results = this.engine.evaluate(snapshot, 3);

    if (results.length > 0) {
      let top = results[0];
      if (this.isOnCooldown(top.ruleId)) return;

      let rec: ContextRecommendation = {
        rule: {
          id: top.ruleId,
          trigger: {} as RuleTrigger,
          action: top.action as UserAction,
          confidence: top.confidence,
          triggerCount: 0,
          acceptCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          enabled: true
        },
        action: top.action as UserAction,
        reason: `åŸºäºå½“å‰æƒ…æ™¯æ¨è (${Math.round(top.confidence * 100)}% åŒ¹é…)`
      };

      this.notifyRecommendation(rec);
      this.setOnCooldown(top.ruleId);
      return;
    }

    // C++ engine returned no matches â€” try LLM fallback
    this.log.info(TAG, 'No engine matches, trying LLM fallback');
    let llmResult = await this.llmFallback.analyzeContext(snapshot);
    if (!llmResult) return;

    let llmRuleId = `user_llm_${Date.now()}`;
    if (this.isOnCooldown('llm_fallback')) return;

    let rec: ContextRecommendation = {
      rule: {
        id: llmRuleId,
        trigger: {} as RuleTrigger,
        action: { type: 'show_info', target: 'llm_suggestion' } as UserAction,
        confidence: llmResult.priority === 'high' ? 0.9 : llmResult.priority === 'medium' ? 0.7 : 0.5,
        triggerCount: 0,
        acceptCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        enabled: true
      },
      action: { type: 'show_info', target: 'llm_suggestion' } as UserAction,
      reason: `${llmResult.title}: ${llmResult.content}`
    };

    this.notifyRecommendation(rec);
    this.setOnCooldown('llm_fallback');

    // === Persist LLM result as a C++ engine rule for future matching ===
    try {
      let conditions: EngineCondition[] = this.snapshotToConditions(snapshot);
      let actionPayload = `${llmResult.title}: ${llmResult.content}`;
      let cooldownMs = llmResult.priority === 'high' ? 3600000 : llmResult.priority === 'medium' ? 14400000 : 28800000;

      let newRule: EngineRule = {
        id: llmRuleId,
        name: llmResult.title,
        conditions: conditions,
        action: { id: `llm_action_${Date.now()}`, type: 'suggestion', payload: actionPayload } as EngineAction,
        priority: llmResult.priority === 'high' ? 2.0 : llmResult.priority === 'medium' ? 1.5 : 1.0,
        cooldownMs: cooldownMs,
        enabled: true,
      };

      let engine = ContextEngineService.getInstance();
      let ok = await engine.addRule(newRule);
      this.log.info(TAG, `LLM rule persisted: id=${llmRuleId}, name=${llmResult.title}, ok=${ok}, totalRules=${engine.getRuleCount()}`);
    } catch (err) {
      this.log.warn(TAG, `Failed to persist LLM rule: ${(err as Error).message}`);
    }

    // Log to BehaviorLogger with source='llm'
    let ctx = this.currentContext ?? await this.getCurrentContext();
    let llmAction: UserAction = { type: 'show_info', target: 'llm_suggestion', params: { 'source': 'llm', 'title': llmResult.title } };
    await this.behaviorLog.logBehavior(ctx, llmAction);
    this.log.info(TAG, `LLM fallback delivered and persisted: ${llmResult.title}`);
  }

  
  private async onGeofenceEvent(event: GeofenceEvent): Promise<void> {
    this.log.info(TAG, `Geofence ${event.type}: ${event.geofence.name}`);

    // æ›´æ–°ä½ç½®
    this.lastLocation = event.location;

    // å†™å…¥æ‰˜ç›˜
    this.tray.put('latitude', event.location.latitude.toString(), 1.0, 'gps');
    this.tray.put('longitude', event.location.longitude.toString(), 1.0, 'gps');
    if (event.type === 'enter') {
      this.tray.put('geofence', event.geofence.id, 1.0, 'geofence');
    }

    // Push event to engine buffer for temporal/sequence rules
    let eventType = event.type === 'enter' ? 'geofence_enter' : 'geofence_exit';
    this.engine.pushEvent(eventType);

    // GPS é«˜ç²¾åº¦è¿›å…¥å›´æ æ—¶ï¼Œå­¦ä¹  WiFi/BT ä¿¡å·
    if (event.type === 'enter') {
      this.locationFusion.learnSignals(event.geofence.id, event.location);
    }

    // åªå¤„ç†è¿›å…¥äº‹ä»¶
    if (event.type !== 'enter') return;

    // åˆ·æ–°æ‰˜ç›˜ + é€šè¿‡ C++ è§„åˆ™å¼•æ“è¯„ä¼°
    await this.refreshTray();
    let snapshot = this.tray.getSnapshot();
    this.log.info(TAG, `Geofence trigger evaluate: geofence=${snapshot.geofence ?? 'none'}`);
    await this.evaluateAndDeliver(snapshot);
    
    this.evaluateAndDeliver(snapshot);

    // åŒæ—¶å°è¯•æ—§çš„ BehaviorLogger åŒ¹é…ï¼ˆå…¼å®¹è¿‡æ¸¡ï¼‰
    let ctx = await this.getCurrentContext();
    let rules = this.behaviorLog.getMatchingRules(ctx);
    if (rules.length > 0) {
      let topRule = rules[0];
      if (!this.isOnCooldown(topRule.id)) {
        let rec: ContextRecommendation = {
          rule: topRule,
          action: topRule.action,
          reason: this.buildRecommendationReason(topRule, event.geofence),
        };
        this.notifyRecommendation(rec);
        this.setOnCooldown(topRule.id);
      }
    } else {
      this.handleNewLocationWithoutRules(event.geofence, ctx);
    }
  }
  
  /**
   * å¤„ç†æ²¡æœ‰è§„åˆ™çš„æ–°ä½ç½® - åŸºäºä½ç½®ç±»å‹çš„é»˜è®¤æ¨è
   */
  private handleNewLocationWithoutRules(geofence: Geofence, ctx: EnvironmentContext): void {
    let defaultAction: UserAction | undefined;
    let reason: string = '';
    
    switch (geofence.category) {
      case 'transit':
        defaultAction = { type: 'show_qrcode', target: 'transit_code' };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼Œéœ€è¦ä¹˜è½¦ç å—ï¼Ÿ`;
        break;
        
      case 'shopping':
        let store = (geofence.metadata && geofence.metadata['store']) ? geofence.metadata['store'] as string : 'store';
        defaultAction = { type: 'show_info', target: `deals_${store}` };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼ŒæŸ¥çœ‹ä»Šæ—¥ä¼˜æƒ ï¼Ÿ`;
        break;
        
      case 'work':
        defaultAction = { type: 'show_info', target: 'calendar_today' };
        reason = `åˆ°è¾¾åŠå…¬å®¤ï¼ŒæŸ¥çœ‹ä»Šæ—¥æ—¥ç¨‹ï¼Ÿ`;
        break;
        
      default:
        return;  // ä¸æ¨è
    }
    
    if (defaultAction && !this.isOnCooldown(`default_${geofence.id}`)) {
      let rec: ContextRecommendation = {
        rule: {
          id: `default_${geofence.id}`,
          trigger: { geofenceIds: [geofence.id] },
          action: defaultAction,
          confidence: 0.5,  // é»˜è®¤æ¨èçš„åˆå§‹ç½®ä¿¡åº¦
          triggerCount: 0,
          acceptCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          enabled: true,
        },
        action: defaultAction,
        reason,
      };
      
      this.notifyRecommendation(rec);
      this.setOnCooldown(`default_${geofence.id}`);
    }
  }
  
  private buildRecommendationReason(rule: ContextRule, geofence: Geofence): string {
    let conf = Math.round(rule.confidence * 100);
    
    if (rule.action.type === 'show_qrcode') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œæ˜¾ç¤ºä¹˜è½¦ç ï¼Ÿ(${conf}% åŒ¹é…)`;
    } else if (rule.action.type === 'show_info') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œä¸ºä½ å‡†å¤‡äº†ç›¸å…³ä¿¡æ¯ (${conf}% åŒ¹é…)`;
    } else {
      return `åŸºäºä½ çš„ä¹ æƒ¯ï¼Œæ¨èæ­¤æ“ä½œ (${conf}% åŒ¹é…)`;
    }
  }
  
  
  /**
   * Convert a ContextSnapshot into ContextCondition[] for rule persistence.
   * Extracts the key fields that defined this context moment.
   */
  private snapshotToConditions(snapshot: ContextSnapshot): EngineCondition[] {
    let conditions: EngineCondition[] = [];

    // Time of day
    conditions.push({ key: 'timeOfDay', op: 'eq', value: snapshot.timeOfDay });

    // Hour range: Â±1 hour for flexibility
    let hour = parseInt(snapshot.hour);
    if (!isNaN(hour)) {
      let low = Math.max(0, hour - 1);
      let high = Math.min(23, hour + 1);
      conditions.push({ key: 'hour', op: 'range', value: `${low},${high}` });
    }

    // Weekend
    conditions.push({ key: 'isWeekend', op: 'eq', value: snapshot.isWeekend });

    // Motion state
    if (snapshot.motionState && snapshot.motionState !== 'unknown') {
      conditions.push({ key: 'motionState', op: 'eq', value: snapshot.motionState });
    }

    // Battery (only if notably low)
    let battery = parseInt(snapshot.batteryLevel);
    if (!isNaN(battery) && battery <= 20) {
      conditions.push({ key: 'batteryLevel', op: 'lte', value: '20' });
    }

    // Charging
    if (snapshot.isCharging === 'true') {
      conditions.push({ key: 'isCharging', op: 'eq', value: 'true' });
    }

    // Network
    if (snapshot.networkType && snapshot.networkType !== 'unknown') {
      conditions.push({ key: 'networkType', op: 'eq', value: snapshot.networkType });
    }

    // Geofence
    if (snapshot.geofence && snapshot.geofence.length > 0) {
      conditions.push({ key: 'geofence', op: 'eq', value: snapshot.geofence });
    }

    return conditions;
  }

  private isOnCooldown(ruleId: string): boolean {
    let lastTime = this.lastRecommendations.get(ruleId);
    if (!lastTime) return false;
    return Date.now() - lastTime < ContextAwarenessService.RECOMMENDATION_COOLDOWN_MS;
  }
  
  private setOnCooldown(ruleId: string): void {
    this.lastRecommendations.set(ruleId, Date.now());
  }
  

  /**
   * ç”¨æˆ·å¯¹æ¨èçš„åé¦ˆï¼ˆä¿ç•™æ—§ API å…¼å®¹æ€§ï¼‰
   */
  async onRecommendationFeedback(
    rec: ContextRecommendation,
    accepted: boolean
  ): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();

    let outcome: ActionOutcome = {
      accepted,
      feedback: accepted ? 1 : -1,
    };

    // è®°å½•è¡Œä¸º
    await this.behaviorLog.logBehavior(ctx, rec.action, outcome);

    this.log.info(TAG, 'Recommendation feedback: ' + rec.rule.id + ' accepted=' + accepted.toString());
  }

  /**
   * å¡ç‰‡å±•ç¤ºæ—¶é€šçŸ¥ FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
   */
  onCardShown(rec: ContextRecommendation): void {
    this.feedbackSvc.onCardShown(rec);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward +1.0
   */
  async onThumbsUp(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsUp(ruleId, ctx);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward -0.5
   */
  async onThumbsDown(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsDown(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ‰§è¡Œæ¨èåŠ¨ä½œ â†’ reward +0.8
   */
  async onActionTaken(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onActionTaken(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ»‘èµ°å¡ç‰‡ â†’ 5min å reward -0.1
   */
  onCardDismissed(ruleId: string): void {
    this.feedbackSvc.onCardDismissed(ruleId);
  }

  /**
   * è·å–åé¦ˆç»Ÿè®¡
   */
  getFeedbackStats(): FeedbackStats {
    return this.feedbackSvc.getStats();
  }
  
  
  addRecommendationListener(listener: RecommendationListener): void {
    this.recommendationListeners.push(listener);
  }
  
  removeRecommendationListener(listener: RecommendationListener): void {
    let idx = this.recommendationListeners.indexOf(listener);
    if (idx >= 0) this.recommendationListeners.splice(idx, 1);
  }
  
  private notifyRecommendation(rec: ContextRecommendation): void {
    this.log.info(TAG, 'Recommendation: ' + rec.reason);
    // æ³¨å†Œå¡ç‰‡åˆ° FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
    this.feedbackSvc.onCardShown(rec);
    for (let i = 0; i < this.recommendationListeners.length; i++) {
      try {
        this.recommendationListeners[i](rec);
      } catch (err) {
        this.log.warn(TAG, 'Listener error: ' + (err as Error).message);
      }
    }
  }
  
  
  /**
   * æ‰‹åŠ¨è®°å½•ç”¨æˆ·è¡Œä¸ºï¼ˆç”¨äºå­¦ä¹ ç”¨æˆ·ä¹ æƒ¯ï¼‰
   */
  async recordUserAction(action: UserAction, accepted: boolean = true): Promise<void> {
    let ctx = await this.getCurrentContext();
    let outcome: ActionOutcome = { accepted, feedback: accepted ? 1 : 0 };
    await this.behaviorLog.logBehavior(ctx, action, outcome);
  }
  
  
  addGeofence(geofence: Geofence): void {
    this.geofenceMgr.addGeofence(geofence);
    this.geofenceMgr.saveToFile();
    this.rebindAfterGeofenceChange();
  }
  
  removeGeofence(id: string): boolean {
    let result = this.geofenceMgr.removeGeofence(id);
    if (result) {
      this.geofenceMgr.saveToFile();
      this.rebindAfterGeofenceChange();
    }
    return result;
  }

  private rebindAfterGeofenceChange(): void {
    try {
      let geofences = this.geofenceMgr.getAllGeofences();
      let bindings: GeofenceBinding[] = [];
      for (let i = 0; i < geofences.length; i++) {
        bindings.push({ id: geofences[i].id, category: geofences[i].category });
      }
      this.engine.rebindGeofences(bindings);
      this.log.info(TAG, `å›´æ å˜æ›´åé‡æ–°ç»‘å®šè§„åˆ™ï¼Œå›´æ æ•°: ${geofences.length}`);
    } catch (err) {
      this.log.warn(TAG, `rebind failed: ${(err as Error).message}`);
    }
  }
  
  getAllGeofences(): Geofence[] {
    return this.geofenceMgr.getAllGeofences();
  }
  
  

  /** è·å–æ‰€æœ‰å›´æ çš„å·²å­¦ä¹ ä¿¡å·æ‘˜è¦ï¼ˆç”¨äºè®¾ç½®é¡µå±•ç¤ºï¼‰ */
  getLearnedSignalsSummaries(): LearnedSignalsSummary[] {
    return this.locationFusion.getLearnedSignalsSummaries(this.geofenceMgr.getAllGeofences());
  }

  /** æ¸…é™¤æŸä¸ªå›´æ çš„å·²å­¦ä¹ ä¿¡å· */
  async clearLearnedSignals(geofenceId: string): Promise<void> {
    await this.locationFusion.clearLearnedSignals(geofenceId);
  }

  /** æ¸…é™¤æ‰€æœ‰å·²å­¦ä¹ ä¿¡å· */
  async clearAllLearnedSignals(): Promise<void> {
    await this.locationFusion.clearAllLearnedSignals();
  }



  addSuggestionListener(listener: SuggestionListener): void {
    this.suggestionListeners.push(listener);
  }

  removeSuggestionListener(listener: SuggestionListener): void {
    let idx = this.suggestionListeners.indexOf(listener);
    if (idx >= 0) this.suggestionListeners.splice(idx, 1);
  }

  private notifySuggestionListeners(suggestions: GeofenceSuggestion[]): void {
    for (let i = 0; i < this.suggestionListeners.length; i++) {
      try {
        this.suggestionListeners[i](suggestions);
      } catch (err) {
        this.log.warn(TAG, 'Suggestion listener error: ' + (err as Error).message);
      }
    }
  }

  /**
   * Filter raw suggestions: remove blacklisted, deferred (< 7 days), daily-cooled,
   * and clusters that already have a matching geofence.
   */
  private filterSuggestions(raw: GeofenceSuggestion[]): GeofenceSuggestion[] {
    let now = Date.now();
    let existingGeofences = this.geofenceMgr.getAllGeofences();
    let result: GeofenceSuggestion[] = [];

    for (let i = 0; i < raw.length; i++) {
      let s = raw[i];

      // Skip blacklisted
      if (this.suggestionState.blacklist.indexOf(s.id) >= 0) continue;

      // Skip deferred (within 7 days)
      let deferredAt = this.suggestionState.deferred[s.id];
      if (deferredAt !== undefined && (now - deferredAt) < DEFER_DURATION_MS) continue;

      // Skip daily cooldown (already shown today)
      let lastShown = this.suggestionState.lastShown[s.id];
      if (lastShown !== undefined && (now - lastShown) < DAILY_COOLDOWN_MS) continue;

      // Skip if a geofence already covers this cluster (within 200m)
      let alreadyCovered = false;
      for (let gi = 0; gi < existingGeofences.length; gi++) {
        let gf = existingGeofences[gi];
        let dist = this.haversineDistance(s.latitude, s.longitude, gf.latitude, gf.longitude);
        if (dist < 200) {
          alreadyCovered = true;
          break;
        }
      }
      if (alreadyCovered) continue;

      result.push(s);
    }

    return result;
  }

  /**
   * Accept a suggestion: create geofence with the user's chosen name/category.
   */
  acceptSuggestion(suggestion: GeofenceSuggestion, name: string, category: string): void {
    let gf: Geofence = {
      id: 'auto_' + Date.now().toString(),
      name: name,
      latitude: suggestion.latitude,
      longitude: suggestion.longitude,
      radiusMeters: suggestion.radiusMeters,
      category: category as GeofenceCategory,
    };
    this.addGeofence(gf);
    this.log.info(TAG, `Accepted suggestion "${name}" as geofence ${gf.id}`);
  }

  /**
   * Ignore a suggestion permanently (blacklist).
   */
  ignoreSuggestion(clusterId: string): void {
    if (this.suggestionState.blacklist.indexOf(clusterId) < 0) {
      this.suggestionState.blacklist.push(clusterId);
    }
    // Clean up deferred/lastShown entries
    this.suggestionState.deferred[clusterId] = 0;
    this.suggestionState.lastShown[clusterId] = 0;
    this.saveSuggestionState();
    this.log.info(TAG, `Blacklisted suggestion: ${clusterId}`);
  }

  /**
   * Defer a suggestion ("ä»¥åå†è¯´") â€” may resurface after 7 days.
   */
  deferSuggestion(clusterId: string): void {
    this.suggestionState.deferred[clusterId] = Date.now();
    this.saveSuggestionState();
    this.log.info(TAG, `Deferred suggestion: ${clusterId}`);
  }

  /**
   * Get currently actionable suggestions (filtered).
   */
  getFilteredSuggestions(): GeofenceSuggestion[] {
    let raw = this.locationDiscovery.getSuggestions();
    return this.filterSuggestions(raw);
  }


  private async loadSuggestionState(): Promise<void> {
    if (!this.context) return;
    try {
      let store = await preferences.getPreferences(this.context, Constants.PREFS_GEOFENCE_SUGGEST);
      let json = (await store.get(SUGGEST_PREFS_KEY, '')) as string;
      if (json.length > 0) {
        let parsed = JSON.parse(json) as GeofenceSuggestionState;
        this.suggestionState = {
          blacklist: parsed.blacklist || [],
          deferred: parsed.deferred || {},
          lastShown: parsed.lastShown || {},
        };
      }
      this.suggestionStateLoaded = true;
      this.log.info(TAG, `Loaded suggestion state: ${this.suggestionState.blacklist.length} blacklisted`);
    } catch (err) {
      this.log.warn(TAG, `Failed to load suggestion state: ${(err as Error).message}`);
      this.suggestionStateLoaded = true;
    }
  }

  private saveSuggestionState(): void {
    if (!this.context) return;
    let json = JSON.stringify(this.suggestionState);
    preferences.getPreferences(this.context, Constants.PREFS_GEOFENCE_SUGGEST).then((store) => {
      return store.put(SUGGEST_PREFS_KEY, json).then(() => store.flush());
    }).catch((err: Error) => {
      this.log.warn(TAG, `Failed to save suggestion state: ${err.message}`);
    });
  }


  private haversineDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    let R = 6371000;
    let dLat = (lat2 - lat1) * Math.PI / 180;
    let dLng = (lng2 - lng1) * Math.PI / 180;
    let a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng / 2) * Math.sin(dLng / 2);
    let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }


  /**
   * æ¨¡æ‹Ÿæƒ…æ™¯æ™ºèƒ½å®Œæ•´ UI æé†’æµç¨‹ï¼ˆå« cooldown æ£€æŸ¥ã€notifyRecommendationã€ç³»ç»Ÿé€šçŸ¥ï¼‰
   * ç”¨äºè°ƒè¯•ï¼šä¸ evaluateAndDeliver èµ°ç›¸åŒè·¯å¾„ï¼Œä½†è¿”å›åŒ¹é…ç»“æœä¾›è°ƒç”¨æ–¹æ£€æŸ¥ã€‚
   */
  async simulateContext(snapshot: ContextSnapshot): Promise<MatchResult[]> {
    await this.evaluateAndDeliver(snapshot);
    // è¿”å›å¼•æ“åŒ¹é…ç»“æœï¼ˆevaluateAndDeliver å†…éƒ¨å·²å¤„ç†æ¨é€ï¼‰
    return this.engine.evaluate(snapshot, 3);
  }

  getStatus(): string {
    let stats = this.behaviorLog.getStats();
    return `Running: ${this.isRunning}, ` +
           `Geofences: ${this.geofenceMgr.getAllGeofences().length}, ` +
           `Records: ${stats.totalRecords}, ` +
           `Rules: ${stats.enabledRules}/${stats.totalRules}, ` +
           `AvgConf: ${(stats.avgConfidence * 100).toFixed(0)}%`;
  }

  /** è·å–æ•°æ®æ‰˜ç›˜çŠ¶æ€ï¼ˆè°ƒè¯•ç”¨ï¼‰ */
  getTrayStatus(): TrayStatus[] {
    return this.tray.getStatus();
  }
  
  isActive(): boolean {
    return this.isRunning;
  }

  /** Access digital world service for plugin status/control */
  getDigitalWorldService(): DigitalWorldService {
    return this.digitalWorld;
  }
}
