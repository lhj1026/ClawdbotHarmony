/**
 * Context Awareness Service
 * 
 * æ ¸å¿ƒæœåŠ¡ï¼šæ•´åˆä¼ æ„Ÿå™¨ã€åœ°ç†å›´æ ã€è¡Œä¸ºè®°å½•å’Œæ¨è
 */
import { sensor } from '@kit.SensorServiceKit';
import { batteryInfo } from '@kit.BasicServicesKit';
import { wifiManager } from '@kit.ConnectivityKit';
import { geoLocationManager } from '@kit.LocationKit';
import { common, abilityAccessCtrl } from '@kit.AbilityKit';
import { preferences } from '@kit.ArkData';
import { LogService } from '../../common/LogService';
import { Constants } from '../../common/Constants';
import { I18n } from '../../common/I18n';
import { GeofenceManager, GeofenceEvent } from './GeofenceManager';
import { BehaviorLogger } from './BehaviorLogger';
import { ContextEngineService, ContextSnapshot, ContextRule as EngineRule, ContextCondition as EngineCondition, ContextAction as EngineAction, MatchResult, GeofenceBinding } from './ContextEngine';
import { LocationDiscoveryService, GeofenceSuggestion, DiscoveryStatsInfo } from './LocationDiscoveryService';
import { FeedbackService } from './FeedbackService';
import { LocationFusionService, LearnedSignalsSummary } from './LocationFusionService';
import { DigitalWorldService } from './DigitalWorldService';
import DataTray, { DataTray as SensorDataTray, TrayStatus } from './DataTray';
import {
  EnvironmentContext,
  MotionState,
  TimeOfDay,
  NetworkType,
  UserAction,
  ActionOutcome,
  ContextRule,
  RuleTrigger,
  Geofence,
  LocationState,
  FeedbackStats,
  LLMRecommendation,
  GeofenceCategory,
} from './ContextModels';
import { LLMFallbackService } from './LLMFallbackService';

const TAG = 'ContextService';

export interface ContextRecommendation {
  rule: ContextRule;
  action: UserAction;
  reason: string;
}

type RecommendationListener = (rec: ContextRecommendation) => void;
type SuggestionListener = (suggestions: GeofenceSuggestion[]) => void;

/** Persisted state for geofence suggestion filtering */
interface GeofenceSuggestionState {
  /** Cluster IDs the user permanently ignored */
  blacklist: string[];
  /** Cluster ID â†’ timestamp when deferred ("ä»¥åå†è¯´"), resurface after 7 days */
  deferred: Record<string, number>;
  /** Cluster ID â†’ timestamp of last suggestion shown, max once per day */
  lastShown: Record<string, number>;
}

const SUGGEST_PREFS_KEY = 'geofence_suggestion_state';
const DEFER_DURATION_MS = 7 * 24 * 3600 * 1000;     // 7 days
const DAILY_COOLDOWN_MS = 24 * 3600 * 1000;          // 24 hours

/** åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨æ•°æ®æ¥å£ */
interface AccelerometerData {
  x: number;
  y: number;
  z: number;
}

export class ContextAwarenessService {
  private static instance: ContextAwarenessService;
  private log: LogService = LogService.getInstance();
  
  private geofenceMgr: GeofenceManager;
  private behaviorLog: BehaviorLogger;
  private feedbackSvc: FeedbackService;
  
  private initialized: boolean = false;
  private isRunning: boolean = false;
  private context: common.UIAbilityContext | undefined;
  
  // å½“å‰çŠ¶æ€
  private currentContext: EnvironmentContext | undefined;
  private lastLocation: LocationState | undefined;
  private lastMotionState: MotionState = 'unknown';
  
  // ä¼ æ„Ÿå™¨æ•°æ®
  private accelerometerData: AccelerometerData = { x: 0, y: 0, z: 0 } as AccelerometerData;
  private stepCount: number = 0;
  
  // WiFi çŠ¶æ€è·Ÿè¸ª
  private lastWifiSsid: string = '';
  private wifiLostWorkTimestamp: number = 0;  // backward compat
  private wifiLostTimestamps: Map<string, number> = new Map();  // category â†’ timestamp
  private static readonly WIFI_LOST_TTL_MS = 10 * 60 * 1000;  // WiFiä¸¢å¤±æ ‡è®°ä¿æŒ10åˆ†é’Ÿ
  
  // æ¨èç›‘å¬å™¨
  private recommendationListeners: RecommendationListener[] = [];
  
  // C++ è§„åˆ™å¼•æ“
  private engine: ContextEngineService = ContextEngineService.getInstance();
  private evaluationTimer: number = -1;
  private static readonly EVALUATION_INTERVAL_MS = 2 * 60 * 1000;  // 2åˆ†é’Ÿè¯„ä¼°ä¸€æ¬¡
  
  // é˜²æŠ–ï¼šé¿å…é‡å¤æ¨è
  private lastRecommendations: Map<string, number> = new Map();
  private lastDigitalData: Record<string, string> = {};
  private static readonly RECOMMENDATION_COOLDOWN_MS = 5 * 60 * 1000;  // 5åˆ†é’Ÿå†·å´
  
  // ä½ç½®è‡ªåŠ¨å‘ç°
  private locationDiscovery: LocationDiscoveryService = LocationDiscoveryService.getInstance();
  private discoveryTimer: number = -1;
  private static readonly DISCOVERY_INTERVAL_MS = 60 * 60 * 1000;  // 1å°æ—¶å‘ç°ä¸€æ¬¡

  // LLM å…œåº•æœåŠ¡
  private llmFallback: LLMFallbackService = LLMFallbackService.getInstance();
  // å¤šæºä½ç½®èåˆ
  private locationFusion: LocationFusionService = LocationFusionService.getInstance();
  // å›´æ å»ºè®®ç®¡ç†
  private suggestionListeners: SuggestionListener[] = [];
  private suggestionState: GeofenceSuggestionState = { blacklist: [], deferred: {}, lastShown: {} };
  private suggestionStateLoaded: boolean = false;
  // A2UI ç›‘å¬å™¨ (æœ¬åœ°UIåˆ†å‘)
  private a2uiListeners: ((type: string, content: string) => void)[] = [];
  // æ–°åœ°ç‚¹è‡ªåŠ¨å‘ç°
  private newPlaceDetectionStart: number = 0;
  private newPlaceLastLat: number = 0;
  private newPlaceLastLng: number = 0;
  private newPlaceWifiSsid: string = '';
  private static readonly NEW_PLACE_STABLE_MS = 5 * 60 * 1000;
  private static readonly NEW_PLACE_MAX_DRIFT_M = 100;
  
  // ==================== å¤šçº§é‡‡é›†ç­–ç•¥ (åŠŸè€—ä¼˜åŒ–) ====================
  // GPSé—´éš”
  private locationTimer: number = -1;
  private locationIntervalMs: number = 60 * 1000;
  private static readonly GPS_STATIONARY = 5 * 60 * 1000;      // é™æ­¢: 5åˆ†é’Ÿ
  private static readonly GPS_WALKING = 30 * 1000;             // æ­¥è¡Œ: 30ç§’
  private static readonly GPS_RUNNING = 15 * 1000;             // è·‘æ­¥: 15ç§’
  private static readonly GPS_DRIVING = 5 * 1000;              // é©¾é©¶: 5ç§’
  private static readonly GPS_UNKNOWN = 60 * 1000;             // æœªçŸ¥: 1åˆ†é’Ÿ
  
  // WiFiæ‰«æé—´éš”
  private wifiTimer: number = -1;
  private wifiIntervalMs: number = 2 * 60 * 1000;
  private static readonly WIFI_STATIONARY = 5 * 60 * 1000;     // é™æ­¢: 5åˆ†é’Ÿ
  private static readonly WIFI_WALKING = 2 * 60 * 1000;        // æ­¥è¡Œ: 2åˆ†é’Ÿ
  private static readonly WIFI_RUNNING = 5 * 60 * 1000;        // è·‘æ­¥: 5åˆ†é’Ÿ (ä¸å¤ªå¯èƒ½è¿WiFi)
  private static readonly WIFI_DRIVING = 0;                     // é©¾é©¶: å…³é—­
  private static readonly WIFI_UNKNOWN = 2 * 60 * 1000;
  
  // åŠ é€Ÿåº¦è®¡é—´éš” (çº³ç§’)
  private accelIntervalNs: number = 1000000000;  // 1ç§’
  private static readonly ACCEL_STATIONARY = 5000000000;       // é™æ­¢: 5ç§’
  private static readonly ACCEL_WALKING = 1000000000;          // æ­¥è¡Œ: 1ç§’
  private static readonly ACCEL_RUNNING = 500000000;           // è·‘æ­¥: 500ms
  private static readonly ACCEL_DRIVING = 2000000000;          // é©¾é©¶: 2ç§’
  private static readonly ACCEL_UNKNOWN = 1000000000;
  
  // æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
  private digitalWorld: DigitalWorldService = DigitalWorldService.getInstance();
  // ä¼ æ„Ÿå™¨æ•°æ®æ‰˜ç›˜
  private tray: SensorDataTray = DataTray;

  private constructor() {
    this.geofenceMgr = GeofenceManager.getInstance();
    this.behaviorLog = BehaviorLogger.getInstance();
    this.feedbackSvc = FeedbackService.getInstance();
  }
  
  static getInstance(): ContextAwarenessService {
    if (!ContextAwarenessService.instance) {
      ContextAwarenessService.instance = new ContextAwarenessService();
    }
    return ContextAwarenessService.instance;
  }
  
  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = context;
    
    await this.geofenceMgr.init(context);
    await this.behaviorLog.init(context);
    
    // åˆå§‹åŒ– C++ è§„åˆ™å¼•æ“
    await this.engine.init(context);
    if (this.engine.getRuleCount() === 0) {
      await this.engine.loadDefaultRules();
      this.log.info(TAG, `Loaded default rules: ${this.engine.getRuleCount()}`);
    }
    
    // åˆå§‹åŒ–å¤šæºä½ç½®èåˆ
    await this.locationFusion.init(context);

    // åˆå§‹åŒ–ä½ç½®å‘ç°æœåŠ¡
    await this.locationDiscovery.init(context);
    await this.feedbackSvc.init(context);
    await this.loadSuggestionState();

    // åˆå§‹åŒ– LLM å…œåº•æœåŠ¡
    this.llmFallback.init(context);

    // åˆå§‹åŒ–æ•°å­—ä¸–ç•Œæ„ŸçŸ¥æœåŠ¡
    // TODO [Digital World Integration]: DigitalWorldService provides digital context
    // (calendar events, screen state, audio scene, etc.) that enriches the ContextSnapshot.
    // Currently initialized and polled independently; data is merged in buildSnapshot().
    await this.digitalWorld.init(context);

    // ç›‘å¬åœ°ç†å›´æ äº‹ä»¶
    this.geofenceMgr.addListener((event) => this.onGeofenceEvent(event));

    this.initialized = true;
    this.log.info(TAG, `Context Awareness Service initialized, rules: ${this.engine.getRuleCount()}`);
  }
  
  
  async start(): Promise<boolean> {
    if (this.isRunning) return true;
    if (!this.initialized) {
      this.log.error(TAG, 'Service not initialized');
      return false;
    }
    
    try {
      // è¯·æ±‚ä½ç½®æƒé™
      let locationGranted = await this.requestLocationPermission();
      
      // è¯·æ±‚è¿åŠ¨ä¼ æ„Ÿå™¨æƒé™å¹¶å¯åŠ¨
      await this.requestMotionPermission();
      this.startMotionSensors();
      
      // å¯åŠ¨WiFiå®šæ—¶æ‰«æ (å¤šçº§é‡‡é›†)
      this.startWifiTimer();
      
      // å¯åŠ¨å®šæ—¶è§„åˆ™è¯„ä¼°
      this.startPeriodicEvaluation();

      // å¯åŠ¨æ™ºèƒ½ä½ç½®è·å–ï¼ˆå¤šçº§é‡‡é›†ï¼‰
      if (locationGranted) {
        this.startSmartLocationTimer();
        this.startLocationDiscovery();
      } else {
        this.log.warn(TAG, 'Location permission denied, location features disabled');
      }

      // å¯åŠ¨æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
      this.digitalWorld.start();

      this.isRunning = true;
      this.log.info(TAG, 'Context Awareness Service started (multi-tier sensing enabled)');
      return true;
    } catch (err) {
      this.log.error(TAG, `Failed to start: ${(err as Error).message}`);
      return false;
    }
  }
  
  stop(): void {
    if (!this.isRunning) return;
    
    this.stopSmartLocationTimer();
    this.stopWifiTimer();
    this.stopMotionSensors();
    this.stopPeriodicEvaluation();
    this.stopLocationDiscovery();
    this.digitalWorld.stop();

    this.isRunning = false;
    this.log.info(TAG, 'Context Awareness Service stopped');
  }
  
  
  // ==================== WiFi è¿æ¥äº‹ä»¶å¤„ç† ====================
  
  private onWifiDisconnected(): void {
    let lostSsid = this.lastWifiSsid;
    this.log.info(TAG, `WiFi disconnected, last SSID: ${lostSsid}`);

    if (lostSsid.length === 0) return;

    // éå†æ‰€æœ‰å›´æ ï¼Œæ£€æŸ¥ä¸¢å¤±çš„ WiFi æ˜¯å¦åŒ¹é…ä»»ä½•å›´æ çš„å­¦ä¹ ä¿¡å·
    let allGeofences = this.geofenceMgr.getAllGeofences();
    let matchedCategory = '';

    for (let gf of allGeofences) {
      let summary = this.locationFusion.getLearnedSignalsSummary(gf);
      if (summary && summary.wifiSsids.includes(lostSsid)) {
        matchedCategory = gf.category;
        break;
      }
    }

    if (matchedCategory.length > 0) {
      let now = Date.now();
      this.log.info(TAG, `WiFi lost: ${lostSsid} â€” leaving ${matchedCategory} geofence`);
      this.wifiLostTimestamps.set(matchedCategory, now);

      // è®¾ç½®é€šç”¨ä¸¢å¤±æ ‡è®°
      this.tray.put('wifiLost', 'true', 0.8, 'wifi');
      this.tray.put('wifiLostCategory', matchedCategory, 0.8, 'wifi');

      // å‘åå…¼å®¹ï¼šwork ç±»åˆ«åŒæ—¶è®¾ç½® wifiLostWork
      if (matchedCategory === 'work') {
        this.wifiLostWorkTimestamp = now;
        this.tray.put('wifiLostWork', 'true', 0.8, 'wifi');
      }

      this.engine.pushEvent('wifi_lost_' + matchedCategory);

      // ç«‹å³è§¦å‘è¯„ä¼°
      this.refreshTray().then(() => {
        let snapshot = this.augmentSnapshot(this.tray.getSnapshot());
        this.evaluateAndDeliver(snapshot);
      });
    }

    // æ¸…é™¤å½“å‰ WiFi å›´æ åŒ¹é…
    this.tray.put('wifiGeofence', '', 0, 'wifi');
    this.lastWifiSsid = '';
  }
  
  private onWifiConnected(): void {
    // WiFi é‡æ–°è¿æ¥ï¼Œæ¸…é™¤ä¸¢å¤±æ ‡è®°
    this.wifiLostWorkTimestamp = 0;
    this.wifiLostTimestamps.clear();

    // å°è¯•è·å–å½“å‰ SSID å¹¶åŒ¹é…å›´æ 
    try {
      wifiManager.getLinkedInfo().then((info) => {
        let ssid = info.ssid || '';
        if (ssid.startsWith('"') && ssid.endsWith('"')) {
          ssid = ssid.substring(1, ssid.length - 1);
        }
        if (ssid.length === 0) return;

        this.lastWifiSsid = ssid;
        this.tray.put('wifiSsid', ssid, 1.0, 'wifi');

        // éå†æ‰€æœ‰å›´æ æŸ¥æ‰¾åŒ¹é…
        let allGeofences = this.geofenceMgr.getAllGeofences();
        for (let gf of allGeofences) {
          let summary = this.locationFusion.getLearnedSignalsSummary(gf);
          if (summary && summary.wifiSsids.includes(ssid)) {
            this.log.info(TAG, `WiFi connected: ${ssid} matches ${gf.category} geofence`);
            this.tray.put('wifiGeofence', gf.category, 0.9, 'wifi');
            this.engine.pushEvent('wifi_arrive_' + gf.category);

            // ç«‹å³è§¦å‘è¯„ä¼°
            this.refreshTray().then(() => {
              let snapshot = this.augmentSnapshot(this.tray.getSnapshot());
              this.evaluateAndDeliver(snapshot);
            });
            return;
          }
        }
      });
    } catch (err) {
      this.log.debug(TAG, `WiFi connected, get info failed: ${(err as Error).message}`);
    }
  }
  
  /**
   * å¢å¼º snapshotï¼šè¡¥å…… WiFi å›´æ ä¸¢å¤±æ ‡è®°ï¼ˆåŸºäº wifiLostTimestamps çš„ TTLï¼‰
   */
  private augmentSnapshot(snapshot: ContextSnapshot): ContextSnapshot {
    let now = Date.now();
    // æ£€æŸ¥æ‰€æœ‰ WiFi ä¸¢å¤±æ—¶é—´æˆ³ï¼Œæ‰¾æœ€è¿‘çš„æœªè¿‡æœŸè®°å½•
    let latestCategory = '';
    let latestTime = 0;
    this.wifiLostTimestamps.forEach((ts: number, category: string) => {
      if (now - ts < ContextAwarenessService.WIFI_LOST_TTL_MS && ts > latestTime) {
        latestCategory = category;
        latestTime = ts;
      }
    });
    if (latestCategory.length > 0) {
      snapshot.wifiLost = 'true';
      snapshot.wifiLostCategory = latestCategory;
      if (latestCategory === 'work') {
        snapshot.wifiLostWork = 'true';
      }
    }
    return snapshot;
  }

  private async requestMotionPermission(): Promise<boolean> {
    try {
      let atManager = abilityAccessCtrl.createAtManager();
      let result = await atManager.requestPermissionsFromUser(this.context as common.UIAbilityContext,
        ['ohos.permission.ACTIVITY_MOTION', 'ohos.permission.READ_HEALTH_DATA']);
      let motionGranted = result.authResults[0] === 0;
      let healthGranted = result.authResults.length > 1 && result.authResults[1] === 0;
      this.log.info(TAG, `ACTIVITY_MOTION permission: ${motionGranted ? 'granted' : 'denied'}, READ_HEALTH_DATA: ${healthGranted ? 'granted' : 'denied'}`);
      let granted = motionGranted;
      return granted;
    } catch (err) {
      this.log.warn(TAG, `Motion permission request failed: ${(err as Error).message}`);
      return false;
    }
  }

  private async requestLocationPermission(): Promise<boolean> {
    try {
      let atManager = abilityAccessCtrl.createAtManager();
      let result = await atManager.requestPermissionsFromUser(this.context as common.UIAbilityContext,
        ['ohos.permission.APPROXIMATELY_LOCATION', 'ohos.permission.LOCATION']);
      let approxGranted = result.authResults[0] === 0;
      let preciseGranted = result.authResults.length > 1 && result.authResults[1] === 0;
      this.log.info(TAG, `Location permission: approx=${approxGranted ? 'granted' : 'denied'}, precise=${preciseGranted ? 'granted' : 'denied'}`);
      return approxGranted || preciseGranted;
    } catch (err) {
      this.log.warn(TAG, `Location permission request failed: ${(err as Error).message}`);
      return false;
    }
  }

  private startMotionSensors(): void {
    try {
      // åŠ é€Ÿåº¦è®¡ - ç”¨äºè¿åŠ¨çŠ¶æ€æ£€æµ‹
      sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {
        this.accelerometerData = { x: data.x, y: data.y, z: data.z } as AccelerometerData;
        this.updateMotionState();
      }, { interval: 1000000000 });  // 1ç§’é‡‡æ ·
      
      // è®¡æ­¥å™¨
      sensor.on(sensor.SensorId.PEDOMETER, (data: sensor.PedometerResponse) => {
        this.stepCount = data.steps;
        this.tray.put('stepCount', data.steps.toString(), 1.0, 'pedometer');
      }, { interval: 5000000000 });  // 5ç§’é‡‡æ ·
      
      this.log.info(TAG, 'Motion sensors started');
    } catch (err) {
      this.log.warn(TAG, `Sensor error: ${(err as Error).message}`);
    }
  }
  
  private stopMotionSensors(): void {
    try {
      sensor.off(sensor.SensorId.ACCELEROMETER);
      sensor.off(sensor.SensorId.PEDOMETER);
    } catch {
      // ignore
    }
  }
  
  /**
   * åŸºäºåŠ é€Ÿåº¦è®¡æ•°æ®å’ŒGPSé€Ÿåº¦ç»¼åˆåˆ¤æ–­è¿åŠ¨çŠ¶æ€
   * è§£å†³ï¼šå¼€è½¦/é«˜é“åŒ€é€Ÿæ—¶åŠ é€Ÿåº¦å°ä½†é€Ÿåº¦å¿«çš„é—®é¢˜
   */
  private updateMotionState(): void {
    let x = this.accelerometerData.x;
    let y = this.accelerometerData.y;
    let z = this.accelerometerData.z;
    let magnitude = Math.sqrt(x * x + y * y + z * z);
    let gpsSpeed = this.lastLocation?.speed ?? 0;  // m/s
    
    let newState: MotionState;
    
    // ä¼˜å…ˆä½¿ç”¨GPSé€Ÿåº¦åˆ¤æ–­ï¼ˆè§£å†³å¼€è½¦/é«˜é“åŒ€é€Ÿé—®é¢˜ï¼‰
    if (gpsSpeed > 20) {
      // > 72 km/h: é«˜é“/é«˜é€Ÿå…¬è·¯
      newState = 'driving';
    } else if (gpsSpeed > 5) {
      // > 18 km/h: é©¾é©¶/éª‘è¡Œ
      newState = 'driving';
    } else if (gpsSpeed > 1.5) {
      // > 5.4 km/h: è·‘æ­¥/å¿«èµ°
      newState = magnitude > 12 ? 'running' : 'walking';
    } else {
      // GPSé€Ÿåº¦æ…¢æˆ–æ— ï¼Œç”¨åŠ é€Ÿåº¦åˆ¤æ–­
      if (magnitude < 10.5) {
        newState = 'stationary';
      } else if (magnitude < 12) {
        newState = 'walking';
      } else if (magnitude < 15) {
        newState = 'running';
      } else {
        newState = 'driving';
      }
    }
    
    // æ›´æ–°æ•°æ®æ‰˜ç›˜
    this.tray.put('motionState', newState, 0.9, 'accelerometer');
    this.tray.put('gpsSpeed', gpsSpeed.toFixed(2), 0.85, 'gps');

    // è¿åŠ¨çŠ¶æ€å˜åŒ–æ—¶è°ƒæ•´GPSé‡‡æ ·é¢‘ç‡
    if (newState !== this.lastMotionState) {
      this.log.info(TAG, `Motion state: ${this.lastMotionState} -> ${newState}, gpsSpeed=${gpsSpeed.toFixed(1)}m/s`);
      this.engine.pushEvent('motion_' + newState);
      this.lastMotionState = newState;
      this.adjustLocationInterval(newState);
    }
  }

  /**
   * æ ¹æ®è¿åŠ¨çŠ¶æ€è°ƒæ•´æ‰€æœ‰ä¼ æ„Ÿå™¨é‡‡æ ·é—´éš” (å¤šçº§é‡‡é›†)
   */
  private adjustLocationInterval(state: MotionState): void {
    let newGpsInterval: number;
    let newWifiInterval: number;
    let newAccelInterval: number;
    
    switch (state) {
      case 'stationary':
        newGpsInterval = ContextAwarenessService.GPS_STATIONARY;
        newWifiInterval = ContextAwarenessService.WIFI_STATIONARY;
        newAccelInterval = ContextAwarenessService.ACCEL_STATIONARY;
        break;
      case 'walking':
        newGpsInterval = ContextAwarenessService.GPS_WALKING;
        newWifiInterval = ContextAwarenessService.WIFI_WALKING;
        newAccelInterval = ContextAwarenessService.ACCEL_WALKING;
        break;
      case 'running':
        newGpsInterval = ContextAwarenessService.GPS_RUNNING;
        newWifiInterval = ContextAwarenessService.WIFI_RUNNING;
        newAccelInterval = ContextAwarenessService.ACCEL_RUNNING;
        break;
      case 'driving':
        newGpsInterval = ContextAwarenessService.GPS_DRIVING;
        newWifiInterval = ContextAwarenessService.WIFI_DRIVING;
        newAccelInterval = ContextAwarenessService.ACCEL_DRIVING;
        break;
      default:
        newGpsInterval = ContextAwarenessService.GPS_UNKNOWN;
        newWifiInterval = ContextAwarenessService.WIFI_UNKNOWN;
        newAccelInterval = ContextAwarenessService.ACCEL_UNKNOWN;
    }
    
    // è°ƒæ•´GPSé‡‡é›†
    if (newGpsInterval !== this.locationIntervalMs) {
      this.locationIntervalMs = newGpsInterval;
      this.log.info(TAG, `GPS interval: ${newGpsInterval / 1000}s for ${state}`);
      this.restartLocationTimer();
    }
    
    // è°ƒæ•´WiFiæ‰«æ
    if (newWifiInterval !== this.wifiIntervalMs) {
      this.wifiIntervalMs = newWifiInterval;
      this.log.info(TAG, `WiFi interval: ${newWifiInterval / 1000}s for ${state}`);
      this.restartWifiTimer();
    }
    
    // è°ƒæ•´åŠ é€Ÿåº¦è®¡
    if (newAccelInterval !== this.accelIntervalNs) {
      this.accelIntervalNs = newAccelInterval;
      this.log.info(TAG, `Accel interval: ${newAccelInterval / 1000000}ms for ${state}`);
      this.restartAccelerometer();
    }
  }

  /**
   * å¯åŠ¨æ™ºèƒ½ä½ç½®è·å–å®šæ—¶å™¨
   */
  private startSmartLocationTimer(): void {
    if (this.locationTimer !== -1) return;
    
    this.locationTimer = setInterval(() => {
      this.fetchSingleLocation();
    }, this.locationIntervalMs);
    
    this.log.info(TAG, `GPS timer started: ${this.locationIntervalMs / 1000}s`);
    this.fetchSingleLocation();
  }

  private stopSmartLocationTimer(): void {
    if (this.locationTimer !== -1) {
      clearInterval(this.locationTimer);
      this.locationTimer = -1;
    }
  }

  private restartLocationTimer(): void {
    this.stopSmartLocationTimer();
    if (this.locationIntervalMs > 0) {
      this.startSmartLocationTimer();
    }
  }

  /**
   * WiFiæ‰«æå®šæ—¶å™¨ (å¤šçº§é‡‡é›†)
   */
  private startWifiTimer(): void {
    if (this.wifiTimer !== -1 || this.wifiIntervalMs === 0) return;
    
    this.wifiTimer = setInterval(() => {
      this.scanWifi();
    }, this.wifiIntervalMs);
    
    this.log.info(TAG, `WiFi timer started: ${this.wifiIntervalMs / 1000}s`);
    this.scanWifi();
  }

  private stopWifiTimer(): void {
    if (this.wifiTimer !== -1) {
      clearInterval(this.wifiTimer);
      this.wifiTimer = -1;
    }
  }

  private restartWifiTimer(): void {
    this.stopWifiTimer();
    if (this.wifiIntervalMs > 0) {
      this.startWifiTimer();
    }
  }

  private scanWifi(): void {
    try {
      wifiManager.getLinkedInfo().then((info) => {
        let ssid = info.ssid ?? '';
        this.tray.put('wifiSSID', ssid, 0.9, 'wifi');
        
        // å§‹ç»ˆæ›´æ–° lastWifiSsid
        if (ssid !== this.lastWifiSsid) {
          this.log.info(TAG, `WiFi: ${this.lastWifiSsid} -> ${ssid}`);
          this.engine.pushEvent('wifi_change');
        }
        this.lastWifiSsid = ssid;
      }).catch(() => {});
    } catch {
      // ignore
    }
  }

  /**
   * é‡å¯åŠ é€Ÿåº¦è®¡ (å¤šçº§é‡‡é›†)
   */
  private restartAccelerometer(): void {
    try {
      sensor.off(sensor.SensorId.ACCELEROMETER);
    } catch {
      // ignore
    }
    try {
      sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {
        this.accelerometerData = { x: data.x, y: data.y, z: data.z } as AccelerometerData;
        this.updateMotionState();
      }, { interval: this.accelIntervalNs });
    } catch (err) {
      this.log.warn(TAG, `Accelerometer restart failed: ${(err as Error).message}`);
    }
  }

  /**
   * è·å–å•æ¬¡ä½ç½®å¹¶å¤„ç†
   */
  private fetchSingleLocation(): void {
    try {
      // å…ˆè·å–WiFiä¿¡æ¯
      this.refreshWifiSync();
      
      let request: geoLocationManager.CurrentLocationRequest = {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 100,
      };
      
      geoLocationManager.getCurrentLocation(request).then((location) => {
        if (location) {
          this.handleLocationUpdate(location);
        }
      }).catch((err: Error) => {
        this.log.warn(TAG, `Location fetch failed: ${err.message}`);
      });
    } catch (err) {
      this.log.warn(TAG, `Location request error: ${(err as Error).message}`);
    }
  }

  /**
   * åŒæ­¥è·å–WiFiä¿¡æ¯
   */
  private refreshWifiSync(): void {
    try {
      wifiManager.getLinkedInfo().then((info) => {
        let ssid = info.ssid ?? '';
        this.tray.put('wifiSSID', ssid, 0.9, 'wifi');
        if (ssid !== this.lastWifiSsid) {
          this.log.info(TAG, `WiFi: ${this.lastWifiSsid} -> ${ssid}`);
          this.engine.pushEvent('wifi_change');
        }
        this.lastWifiSsid = ssid;
      }).catch(() => {});
    } catch {
      // ignore
    }
  }

  /**
   * å¼‚æ­¥è·å–WiFiä¿¡æ¯
   */
  private async refreshWifiAsync(): Promise<void> {
    try {
      let info = await wifiManager.getLinkedInfo();
      let ssid = info.ssid ?? '';
      this.tray.put('wifiSSID', ssid, 0.9, 'wifi');
      if (ssid !== this.lastWifiSsid) {
        this.log.info(TAG, `WiFi: ${this.lastWifiSsid} -> ${ssid}`);
        this.engine.pushEvent('wifi_change');
      }
      this.lastWifiSsid = ssid;
    } catch {
      // ignore
    }
  }

  /**
   * å¤„ç†ä½ç½®æ›´æ–°
   */
  private handleLocationUpdate(location: geoLocationManager.Location): void {
    let lat = location.latitude;
    let lng = location.longitude;
    let speed = location.speed ?? 0;
    let accuracy = location.accuracy ?? 100;
    
    // æ›´æ–°æ•°æ®æ‰˜ç›˜
    this.tray.put('latitude', lat.toFixed(6), 1.0, 'gps');
    this.tray.put('longitude', lng.toFixed(6), 1.0, 'gps');
    this.tray.put('locationAccuracy', accuracy.toFixed(0), 0.8, 'gps');
    
    // æ£€æŸ¥å›´æ 
    let locState: LocationState = {
      latitude: lat,
      longitude: lng,
      speed: speed,
      accuracy: accuracy,
      timestamp: Date.now(),
      insideGeofences: []
    };
    this.geofenceMgr.updateLocation(locState);
    this.lastLocation = locState;
    
    this.log.debug(TAG, `Location update: (${lat.toFixed(4)}, ${lng.toFixed(4)}) speed=${speed.toFixed(1)}m/s wifi=${this.lastWifiSsid}`);
    
    // æ£€æŸ¥æ–°åœ°ç‚¹ï¼ˆåœç•™5åˆ†é’Ÿ+WiFiï¼‰- å¼‚æ­¥æ‰§è¡Œ
    this.checkForNewPlaceSmart(lat, lng);
  }


  private startPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) return;
    this.evaluationTimer = setInterval(() => {
      this.periodicEvaluate();
    }, ContextAwarenessService.EVALUATION_INTERVAL_MS);
    this.log.info(TAG, 'Started periodic evaluation');
  }

  private stopPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) {
      clearInterval(this.evaluationTimer);
      this.evaluationTimer = -1;
      this.log.info(TAG, 'Stopped periodic evaluation');
    }
  }

  private async periodicEvaluate(): Promise<void> {
    if (!this.isRunning) return;
    // Refresh tray with latest sensor data, then read snapshot from tray
    await this.refreshTray();
    let snapshot = this.tray.getSnapshot();
    await this.evaluateAndDeliver(snapshot);
  }


  private startLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) return;

    // ç›‘å¬ä½ç½®å˜åŒ–ï¼Œè®°å½•åˆ°å‘ç°æœåŠ¡
    this.geofenceMgr.addLocationListener((location) => {
      this.log.info(TAG, `Location update: (${location.latitude.toFixed(4)}, ${location.longitude.toFixed(4)})`);
      this.locationDiscovery.recordLocation(location);
      // æ£€æµ‹æ–°åœ°ç‚¹
      let ssid = this.lastWifiSsid ?? '';
      this.checkForNewPlace(location.latitude, location.longitude, ssid);
    });

    // å®šæ—¶è¿è¡Œèšç±»å‘ç°
    this.discoveryTimer = setInterval(() => {
      this.runLocationDiscovery();
    }, ContextAwarenessService.DISCOVERY_INTERVAL_MS);

    this.log.info(TAG, 'Started location discovery');
  }

  private stopLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) {
      clearInterval(this.discoveryTimer);
      this.discoveryTimer = -1;
      this.log.info(TAG, 'Stopped location discovery');
    }
  }

  private async runLocationDiscovery(): Promise<void> {
    if (!this.isRunning) return;
    let allSuggestions = await this.locationDiscovery.runDiscovery();
    if (allSuggestions.length === 0) return;

    let filtered = this.filterSuggestions(allSuggestions);
    if (filtered.length === 0) {
      this.log.info(TAG, `Discovery found ${allSuggestions.length} raw, all filtered out`);
      return;
    }

    // Mark as shown today
    let now = Date.now();
    for (let i = 0; i < filtered.length; i++) {
      this.suggestionState.lastShown[filtered[i].id] = now;
    }
    this.saveSuggestionState();

    this.log.info(TAG, `Emitting ${filtered.length} geofence suggestions`);
    this.notifySuggestionListeners(filtered);
  }

  /** è·å–ä½ç½®å‘ç°å»ºè®® */
  getLocationSuggestions(): GeofenceSuggestion[] {
    return this.locationDiscovery.getSuggestions();
  }

  /** è·å–ä½ç½®å‘ç°ç»Ÿè®¡ */
  getLocationDiscoveryStats(): DiscoveryStatsInfo {
    return this.locationDiscovery.getStats();
  }

  
  /**
   * åˆ·æ–°æ‰˜ç›˜ï¼šå°†æ‰€æœ‰å¯è½®è¯¢çš„ä¼ æ„Ÿå™¨æ•°æ®å†™å…¥æ‰˜ç›˜
   * äº‹ä»¶é©±åŠ¨çš„æ•°æ®ï¼ˆåŠ é€Ÿåº¦è®¡ã€å›´æ ï¼‰ç”±å›è°ƒç›´æ¥å†™å…¥ã€‚
   */
  private async refreshTray(): Promise<void> {
    let now = new Date();
    let hour = now.getHours();

    // æ—¶é—´ï¼ˆå®æ—¶è®¡ç®—ï¼ŒTTL=âˆï¼‰
    let timeOfDay: TimeOfDay;
    if (hour >= 5 && hour < 12) timeOfDay = 'morning';
    else if (hour >= 12 && hour < 17) timeOfDay = 'afternoon';
    else if (hour >= 17 && hour < 21) timeOfDay = 'evening';
    else timeOfDay = 'night';

    let dayOfWeek = now.getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

    this.tray.put('hour', hour.toString(), 1.0, 'system');
    this.tray.put('timeOfDay', timeOfDay, 1.0, 'system');
    this.tray.put('dayOfWeek', dayOfWeek.toString(), 1.0, 'system');
    this.tray.put('isWeekend', isWeekend ? 'true' : 'false', 1.0, 'system');

    // ç”µæ± 
    try {
      this.tray.put('batteryLevel', batteryInfo.batterySOC.toString(), 1.0, 'battery');
      let charging = batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE;
      this.tray.put('isCharging', charging ? 'true' : 'false', 1.0, 'battery');
    } catch {
      // ignore
    }

    // ç½‘ç»œ + WiFi SSID
    try {
      if (wifiManager.isWifiActive()) {
        this.tray.put('networkType', 'wifi', 1.0, 'wifi');
        try {
          let info = await wifiManager.getLinkedInfo();
          let ssid = info.ssid || '';
          if (ssid.startsWith('"') && ssid.endsWith('"')) {
            ssid = ssid.substring(1, ssid.length - 1);
          }
          if (ssid.length > 0) {
            this.tray.put('wifiSsid', ssid, 1.0, 'wifi');
            this.lastWifiSsid = ssid;
          }
        } catch { /* ignore */ }
      } else {
        this.tray.put('networkType', 'cellular', 0.8, 'network');
      }
    } catch {
      // ignore
    }
    
    // WiFiä¸¢å¤±æ ‡è®°ï¼ˆéå†æ‰€æœ‰ç±»åˆ«ï¼Œæœ‰æ•ˆæœŸå†…ï¼‰
    let nowMs = Date.now();
    this.wifiLostTimestamps.forEach((ts: number, category: string) => {
      if (nowMs - ts < ContextAwarenessService.WIFI_LOST_TTL_MS) {
        this.tray.put('wifiLost', 'true', 0.8, 'wifi');
        this.tray.put('wifiLostCategory', category, 0.8, 'wifi');
        // å‘åå…¼å®¹
        if (category === 'work') {
          this.tray.put('wifiLostWork', 'true', 0.8, 'wifi');
        }
      }
    });

    // ä½ç½® / å›´æ 
    if (this.lastLocation) {
      this.tray.put('latitude', this.lastLocation.latitude.toString(), 1.0, 'gps');
      this.tray.put('longitude', this.lastLocation.longitude.toString(), 1.0, 'gps');

      let geofences = this.geofenceMgr.getGeofencesAtLocation(
        this.lastLocation.latitude,
        this.lastLocation.longitude
      );
      if (geofences.length > 0) {
        this.tray.put('geofence', geofences[0].id, 1.0, 'geofence');
      }
    }

    // æ­¥æ•°
    if (this.stepCount > 0) {
      this.tray.put('stepCount', this.stepCount.toString(), 1.0, 'pedometer');
    }

    // è¿åŠ¨çŠ¶æ€ï¼ˆåŠ é€Ÿåº¦è®¡å›è°ƒå·²å†™å…¥ï¼Œè¿™é‡Œç¡®ä¿æœ‰å€¼ï¼‰
    if (this.lastMotionState !== 'unknown') {
      this.tray.put('motionState', this.lastMotionState, 0.9, 'accelerometer');
    }
  }

  /**
   * è·å–å½“å‰å®Œæ•´çš„ç¯å¢ƒä¸Šä¸‹æ–‡
   * ä¿ç•™ä¾›åé¦ˆè·¯å¾„å’Œå…¼å®¹æ—§ API ä½¿ç”¨ã€‚å†…éƒ¨åŒæ—¶åˆ·æ–°æ‰˜ç›˜ã€‚
   */
  async getCurrentContext(): Promise<EnvironmentContext> {
    // åˆ·æ–°æ‰˜ç›˜ï¼ˆæ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®å†™å…¥ï¼‰
    await this.refreshTray();

    let now = new Date();
    let hour = now.getHours();

    let timeOfDay: TimeOfDay;
    if (hour >= 5 && hour < 12) timeOfDay = 'morning';
    else if (hour >= 12 && hour < 17) timeOfDay = 'afternoon';
    else if (hour >= 17 && hour < 21) timeOfDay = 'evening';
    else timeOfDay = 'night';

    let dayOfWeek = now.getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

    // è®¾å¤‡çŠ¶æ€
    let batteryLevel = 100;
    let isCharging = false;
    try {
      batteryLevel = batteryInfo.batterySOC;
      isCharging = batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE;
    } catch {
      // ignore
    }

    // ç½‘ç»œçŠ¶æ€
    let networkType: NetworkType = 'none';
    try {
      if (wifiManager.isWifiActive()) {
        networkType = 'wifi';
      } else {
        networkType = 'cellular';
      }
    } catch {
      // ignore
    }
    
    // å½“å‰å›´æ ï¼ˆå¤šæºèåˆï¼‰

    // å½“å‰å›´æ 
    let currentGeofence: Geofence | undefined;
    let allGeofences = this.geofenceMgr.getAllGeofences();
    let fusionResult = await this.locationFusion.getBestMatch(allGeofences, this.lastLocation);
    if (fusionResult) {
      currentGeofence = this.geofenceMgr.getGeofence(fusionResult.geofenceId);
      this.log.debug(TAG,
        `Fused location: ${fusionResult.geofenceId} conf=${fusionResult.confidence.toFixed(2)} src=${fusionResult.source}`);
    } else if (this.lastLocation) {
      // é™çº§ï¼šèåˆæ— ç»“æœæ—¶ç”¨åŸå§‹ GPS
      let gpsGeofences = this.geofenceMgr.getGeofencesAtLocation(
        this.lastLocation.latitude,
        this.lastLocation.longitude
      );
      currentGeofence = gpsGeofences[0];
    }

    let ctx: EnvironmentContext = {
      timestamp: Date.now(),
      location: this.lastLocation,
      currentGeofence,
      motionState: this.lastMotionState,
      stepCount: this.stepCount,
      timeOfDay,
      dayOfWeek,
      isWeekend,
      batteryLevel,
      isCharging,
      networkType,
      screenOn: true,
    };

    this.currentContext = ctx;
    return ctx;
  }

  /**
   * æ„å»º C++ è§„åˆ™å¼•æ“éœ€è¦çš„å¿«ç…§æ ¼å¼
   *
   * TODO [Digital World Integration Point]:
   * Digital world data from DigitalWorldService is merged into the snapshot here.
   * The C++ engine's ContextSnapshot currently uses a fixed set of keys (timeOfDay,
   * hour, motionState, etc.), but the evaluate() method passes JSON so additional
   * digital-world keys (cal_hasUpcoming, audio_inCall, screen_locked, etc.) can be
   * matched by rules that reference these keys. New rules can use conditions like:
   *   { key: 'cal_inMeeting', op: 'eq', value: 'true' }
   *   { key: 'audio_inCall', op: 'eq', value: 'true' }
   *   { key: 'screen_locked', op: 'eq', value: 'true' }
   *
   * To fully wire this up:
   * 1. Extend ContextSnapshot interface in ContextEngine.ets with optional digital fields
   * 2. Add built-in rules that reference digital-world keys
   * 3. Connect DigitalWorldService lifecycle to this service (done â€” see init/start/stop)
   */
  private buildSnapshot(ctx: EnvironmentContext): ContextSnapshot {
    let now = new Date();
    let hour = now.getHours();
    let dayOfWeek = now.getDay();

    let snapshot: ContextSnapshot = {
      timeOfDay: ctx.timeOfDay,
      hour: hour.toString(),
      dayOfWeek: dayOfWeek.toString(),
      isWeekend: ctx.isWeekend ? 'true' : 'false',
      motionState: ctx.motionState || 'unknown',
      batteryLevel: ctx.batteryLevel.toString(),
      isCharging: ctx.isCharging ? 'true' : 'false',
      networkType: ctx.networkType || 'none',
      geofence: ctx.currentGeofence?.id,
      latitude: ctx.location?.latitude?.toString(),
      longitude: ctx.location?.longitude?.toString(),
      stepCount: ctx.stepCount?.toString()
    };

    // Merge digital world plugin data into snapshot for rule evaluation
    // Digital data is merged via JSON since ContextSnapshot has fixed keys
    let digitalData = this.digitalWorld.getDigitalData();
    this.lastDigitalData = digitalData;

    return snapshot;
  }

  /**
   * è¯„ä¼°å¹¶æ¨é€æ¨èï¼Œæ— åŒ¹é…æ—¶è°ƒç”¨ LLM å…œåº•
   * è¯„ä¼°å¹¶æ¨é€æ¨è
   */
  private async evaluateAndDeliver(snapshot: ContextSnapshot): Promise<void> {
    let results = this.engine.evaluate(snapshot, 3);

    if (results.length > 0) {
      let top = results[0];
      if (this.isOnCooldown(top.ruleId)) return;

      let rec: ContextRecommendation = {
        rule: {
          id: top.ruleId,
          trigger: {} as RuleTrigger,
          action: top.action as UserAction,
          confidence: top.confidence,
          triggerCount: 0,
          acceptCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          enabled: true
        },
        action: top.action as UserAction,
        reason: `åŸºäºå½“å‰æƒ…æ™¯æ¨è (${Math.round(top.confidence * 100)}% åŒ¹é…)`
      };

      this.notifyRecommendation(rec);
      this.setOnCooldown(top.ruleId);
      return;
    }

    // C++ engine returned no matches â€” try LLM fallback
    this.log.info(TAG, 'No engine matches, trying LLM fallback');
    let llmResult = await this.llmFallback.analyzeContext(snapshot);
    if (!llmResult) return;

    let llmRuleId = `user_llm_${Date.now()}`;
    if (this.isOnCooldown('llm_fallback')) return;

    let rec: ContextRecommendation = {
      rule: {
        id: llmRuleId,
        trigger: {} as RuleTrigger,
        action: { type: 'show_info', target: 'llm_suggestion' } as UserAction,
        confidence: llmResult.priority === 'high' ? 0.9 : llmResult.priority === 'medium' ? 0.7 : 0.5,
        triggerCount: 0,
        acceptCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        enabled: true
      },
      action: { type: 'show_info', target: 'llm_suggestion' } as UserAction,
      reason: `${llmResult.title}: ${llmResult.content}`
    };

    this.notifyRecommendation(rec);
    this.setOnCooldown('llm_fallback');

    // === Persist LLM result as a C++ engine rule for future matching ===
    try {
      let conditions: EngineCondition[] = this.snapshotToConditions(snapshot);
      let actionPayload = `${llmResult.title}: ${llmResult.content}`;
      let cooldownMs = llmResult.priority === 'high' ? 3600000 : llmResult.priority === 'medium' ? 14400000 : 28800000;

      let newRule: EngineRule = {
        id: llmRuleId,
        name: llmResult.title,
        conditions: conditions,
        action: { id: `llm_action_${Date.now()}`, type: 'suggestion', payload: actionPayload } as EngineAction,
        priority: llmResult.priority === 'high' ? 2.0 : llmResult.priority === 'medium' ? 1.5 : 1.0,
        cooldownMs: cooldownMs,
        enabled: true,
      };

      let engine = ContextEngineService.getInstance();
      let ok = await engine.addRule(newRule);
      this.log.info(TAG, `LLM rule persisted: id=${llmRuleId}, name=${llmResult.title}, ok=${ok}, totalRules=${engine.getRuleCount()}`);
    } catch (err) {
      this.log.warn(TAG, `Failed to persist LLM rule: ${(err as Error).message}`);
    }

    // Log to BehaviorLogger with source='llm'
    let ctx = this.currentContext ?? await this.getCurrentContext();
    let llmAction: UserAction = { type: 'show_info', target: 'llm_suggestion', params: { 'source': 'llm', 'title': llmResult.title } };
    await this.behaviorLog.logBehavior(ctx, llmAction);
    this.log.info(TAG, `LLM fallback delivered and persisted: ${llmResult.title}`);
  }

  /**
   * æ£€æµ‹æ–°åœ°ç‚¹ï¼šGPS + WiFi ç¨³å®š 5 åˆ†é’Ÿä¸”ä¸åœ¨ä»»ä½•å·²çŸ¥å›´æ å†…
   */
  private async checkForNewPlace(lat: number, lng: number, wifiSsid: string): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦åœ¨ä»»ä½•å·²çŸ¥å›´æ å†…
    let allGeofences = this.geofenceMgr.getAllGeofences();
    let inKnownGeofence = false;
    for (let i = 0; i < allGeofences.length; i++) {
      let gf = allGeofences[i];
      let dist = this.haversineDistance(lat, lng, gf.latitude, gf.longitude);
      if (dist < gf.radiusMeters) {
        inKnownGeofence = true;
        break;
      }
    }
    
    if (inKnownGeofence) {
      // åœ¨å·²çŸ¥å›´æ å†…ï¼Œé‡ç½®æ£€æµ‹
      this.newPlaceDetectionStart = 0;
      return;
    }
    
    let now = Date.now();
    
    // æ£€æŸ¥ä½ç½®æ˜¯å¦ç¨³å®šï¼ˆä¸ä¸Šæ¬¡è®°å½•çš„å·®å¼‚ < 100mï¼‰
    if (this.newPlaceDetectionStart > 0) {
      let drift = this.haversineDistance(lat, lng, this.newPlaceLastLat, this.newPlaceLastLng);
      if (drift > ContextAwarenessService.NEW_PLACE_MAX_DRIFT_M) {
        // ä½ç½®æ¼‚ç§»å¤ªå¤§ï¼Œé‡ç½®
        this.log.info(TAG, `New place reset: drifted ${Math.round(drift)}m`);
        this.newPlaceDetectionStart = 0;
        return;
      }
    }
    
    // å¼€å§‹æ–°æ£€æµ‹æˆ–ç»§ç»­ç°æœ‰æ£€æµ‹
    if (this.newPlaceDetectionStart === 0) {
      this.newPlaceDetectionStart = now;
      this.newPlaceLastLat = lat;
      this.newPlaceLastLng = lng;
      this.newPlaceWifiSsid = wifiSsid;
      this.log.info(TAG, `New place detection started at (${lat.toFixed(4)}, ${lng.toFixed(4)})`);
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦ç¨³å®šè¶³å¤Ÿæ—¶é—´
    let stableMs = now - this.newPlaceDetectionStart;
    if (stableMs < ContextAwarenessService.NEW_PLACE_STABLE_MS) {
      this.log.debug(TAG, `New place stable for ${Math.round(stableMs / 1000)}s, need ${ContextAwarenessService.NEW_PLACE_STABLE_MS / 1000}s`);
      return;
    }
    
    // ç¨³å®š 5 åˆ†é’Ÿï¼Œæ£€æµ‹åˆ°æ–°åœ°ç‚¹ï¼
    this.log.info(TAG, `New place detected! (${lat.toFixed(4)}, ${lng.toFixed(4)}) WiFi=${wifiSsid}`);
    this.newPlaceDetectionStart = 0;  // é‡ç½®é˜²æ­¢é‡å¤
    
    // å°è¯•é€†åœ°ç†ç¼–ç è·å–åœ°ç‚¹å
    let placeName = await this.reverseGeocode(lat, lng);
    
    // æ˜¾ç¤º A2UI å¡ç‰‡è®©ç”¨æˆ·ç¡®è®¤
    this.showNewPlaceCard(lat, lng, wifiSsid, placeName);
  }

  /**
   * å®æ—¶æ£€æµ‹æ–°åœ°ç‚¹ï¼ˆç»“åˆå½“å‰WiFiçŠ¶æ€ï¼‰
   * åœç•™5åˆ†é’Ÿ+æœ‰WiFiè¿æ¥ â†’ ç«‹å³å‘ç°ï¼Œä¸ç­‰èšç±»
   */
  private async checkForNewPlaceSmart(lat: number, lng: number): Promise<void> {
    // åŒæ—¶å­¦ä¹ å½“å‰å›´æ çš„ç‰¹å¾ï¼ˆä¼šå…ˆè·å–WiFiï¼‰
    await this.learnPlaceSignals(lat, lng);
    
    // æ£€æµ‹æ–°åœ°ç‚¹
    await this.checkForNewPlace(lat, lng, this.lastWifiSsid);
  }

  /**
   * å­¦ä¹ å›´æ ç‰¹å¾ä¿¡å·ï¼šåœ¨å›´æ å†…æ—¶ï¼Œè®°å½•WiFi/è“ç‰™ç­‰ç‰¹å¾
   */
  private async learnPlaceSignals(lat: number, lng: number): Promise<void> {
    let allGeofences = this.geofenceMgr.getAllGeofences();
    
    // å¦‚æœWiFiä¿¡æ¯ä¸ºç©ºï¼Œå°è¯•åŒæ­¥è·å–
    if (!this.lastWifiSsid || this.lastWifiSsid.length === 0) {
      await this.refreshWifiAsync();
    }
    
    this.log.debug(TAG, `learnPlaceSignals: checking ${allGeofences.length} geofences, wifi=${this.lastWifiSsid}`);
    
    for (let i = 0; i < allGeofences.length; i++) {
      let gf = allGeofences[i];
      let dist = this.haversineDistance(lat, lng, gf.latitude, gf.longitude);
      
      if (dist < gf.radiusMeters) {
        this.log.info(TAG, `Inside geofence: ${gf.name}, dist=${Math.round(dist)}m, wifi=${this.lastWifiSsid}`);
        
        // åœ¨æ­¤å›´æ å†…ï¼Œå­¦ä¹ ä¿¡å·
        let signals = gf.learnedSignals ?? {
          wifiSSIDs: [],
          bluetoothDevices: [],
          typicalTimes: [],
          lastSeen: 0,
          visitCount: 0
        };
        
        let updated = false;
        
        // å­¦ä¹ WiFi SSID
        if (this.lastWifiSsid && this.lastWifiSsid.length > 0) {
          if (!signals.wifiSSIDs!.includes(this.lastWifiSsid)) {
            signals.wifiSSIDs!.push(this.lastWifiSsid);
            this.log.info(TAG, `Learned WiFi for ${gf.name}: ${this.lastWifiSsid}`);
            this.notifyGeofenceFeatureLearned(gf.name, 'WiFi', this.lastWifiSsid);
            updated = true;
          }
        } else {
          this.log.debug(TAG, `No WiFi to learn for ${gf.name}`);
        }
        
        // æ›´æ–°è®¿é—®ç»Ÿè®¡
        signals.visitCount = (signals.visitCount ?? 0) + 1;
        signals.lastSeen = Date.now();
        
        // å­¦ä¹ å…¸å‹æ—¶é—´
        let hour = new Date().getHours();
        let timeRange = `${hour}:00-${hour + 1}:00`;
        if (!signals.typicalTimes!.some(t => t.start === timeRange)) {
          signals.typicalTimes!.push({ start: timeRange, end: `${hour + 1}:00` });
          if (signals.typicalTimes!.length > 5) {
            signals.typicalTimes!.shift();
          }
          updated = true;
        }
        
        // ä¿å­˜æ›´æ–°
        if (updated || signals.visitCount === 1) {
          gf.learnedSignals = signals;
          this.geofenceMgr.saveToFile();
        }
        
        // åªå¤„ç†ç¬¬ä¸€ä¸ªåŒ¹é…çš„å›´æ 
        break;
      }
    }
  }

  /**
   * é€šçŸ¥å›´æ å­¦ä¹ åˆ°æ–°ç‰¹å¾
   */
  private notifyGeofenceFeatureLearned(geofenceName: string, featureType: string, featureValue: string): void {
    let titleText = I18n.t('context.geofence.learned');
    let wifiLabelText = I18n.t('context.geofence.newWifi');
    
    let jsonl = '{"type":"form","id":"gf_learn_' + Date.now() + '","children":[' +
      '{"type":"text","text":"ğŸ”— ' + titleText + '","style":{"fontSize":16,"fontWeight":"bold"}},' +
      '{"type":"text","text":"' + geofenceName + '"},' +
      '{"type":"text","text":"' + wifiLabelText + ': ' + featureValue + '","style":{"fontSize":12,"color":"#666"}}' +
      ']}';
    
    this.dispatchA2UI('push', jsonl);
  }

  /**
   * é€†åœ°ç†ç¼–ç ï¼šåæ ‡ â†’ åœ°ç‚¹å
   */
  private async reverseGeocode(lat: number, lng: number): Promise<string> {
    try {
      // ä½¿ç”¨ HarmonyOS é€†åœ°ç†ç¼–ç  API
      let request: geoLocationManager.ReverseGeoCodeRequest = {
        latitude: lat,
        longitude: lng,
        maxItems: 1,
        locale: 'zh'
      };
      let results = await geoLocationManager.getAddressesFromLocation(request);
      if (results && results.length > 0) {
        let addr = results[0];
        // ä¼˜å…ˆä½¿ç”¨åœ°æ ‡åï¼Œå…¶æ¬¡è¡—é“åœ°å€
        let name = addr.placeName ?? addr.roadName ?? '';
        if (name.length === 0 && addr.locality) {
          name = addr.locality;
        }
        if (name.length > 0) {
          this.log.info(TAG, `Reverse geocode: ${name}`);
          return name;
        }
      }
    } catch (err) {
      this.log.warn(TAG, `Reverse geocode failed: ${(err as Error).message}`);
    }
    // å¤±è´¥æ—¶ç”¨åæ ‡ç”Ÿæˆåç§°
    return `æ–°åœ°ç‚¹ (${lat.toFixed(3)}, ${lng.toFixed(3)})`;
  }

  /**
   * æ˜¾ç¤ºæ–°åœ°ç‚¹ç¡®è®¤å¡ç‰‡
   */
  private showNewPlaceCard(lat: number, lng: number, wifiSsid: string, placeName: string): void {
    let escapedName = placeName.replace(/"/g, "'");
    let escapedWifi = wifiSsid.replace(/"/g, "'");
    
    // æ¨æ–­ç±»åˆ«
    let category = this.inferCategoryFromTime();
    
    let titleText = I18n.t('context.newPlace.title');
    let wifiLabel = I18n.t('context.newPlace.wifi');
    let saveAsLabel = I18n.t('context.newPlace.saveAs');
    let renameLabel = I18n.t('context.newPlace.rename');
    let ignoreLabel = I18n.t('context.newPlace.ignore');
    
    let jsonl = '{"type":"form","id":"new_place_' + Date.now() + '","children":[' +
      '{"type":"text","text":"ğŸ“ ' + titleText + '","style":{"fontSize":18,"fontWeight":"bold"}},' +
      '{"type":"text","text":"' + escapedName + '"},' +
      '{"type":"text","text":"' + wifiLabel + ': ' + escapedWifi + '","style":{"fontSize":12,"color":"#666"}}},' +
      '{"type":"row","children":[' +
        '{"type":"button","label":"âœ… ' + saveAsLabel + ' ' + category + '","action":{"event":{"name":"new_place_save","context":{"lat":' + lat + ',"lng":' + lng + ',"wifi":"' + escapedWifi + '","name":"' + escapedName + '","category":"' + category + '"}}},"style":"primary"},' +
        '{"type":"button","label":"âœï¸ ' + renameLabel + '","action":{"event":{"name":"new_place_rename","context":{"lat":' + lat + ',"lng":' + lng + '}}}},"style":"secondary"},' +
        '{"type":"button","label":"âŒ ' + ignoreLabel + '","action":{"event":{"name":"new_place_ignore","context":{}}}},"style":"secondary"}' +
      ']}]}';
    
    this.dispatchA2UI('push', jsonl);
    this.log.info(TAG, `New place card shown: ${placeName}`);
  }

  /**
   * æ ¹æ®å½“å‰æ—¶é—´æ¨æ–­åœ°ç‚¹ç±»åˆ«
   */
  private inferCategoryFromTime(): string {
    let hour = new Date().getHours();
    let dayOfWeek = new Date().getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    
    if (!isWeekend && hour >= 9 && hour < 18) {
      return 'work';
    }
    if (hour >= 22 || hour < 6) {
      return 'home';
    }
    if (hour >= 11 && hour < 14) {
      return 'restaurant';
    }
    if (isWeekend && hour >= 8 && hour < 20) {
      return 'gym';
    }
    return 'other';
  }

  /**
   * è®¡ç®—ä¸¤ç‚¹è·ç¦»ï¼ˆç±³ï¼‰
   */
  private haversineDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    let R = 6371000; // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
    let dLat = (lat2 - lat1) * Math.PI / 180;
    let dLng = (lng2 - lng1) * Math.PI / 180;
    let a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng / 2) * Math.sin(dLng / 2);
    let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  
  private async onGeofenceEvent(event: GeofenceEvent): Promise<void> {
    this.log.info(TAG, `Geofence ${event.type}: ${event.geofence.name}`);

    // æ›´æ–°ä½ç½®
    this.lastLocation = event.location;

    // å†™å…¥æ‰˜ç›˜
    this.tray.put('latitude', event.location.latitude.toString(), 1.0, 'gps');
    this.tray.put('longitude', event.location.longitude.toString(), 1.0, 'gps');
    if (event.type === 'enter') {
      this.tray.put('geofence', event.geofence.id, 1.0, 'geofence');
    }

    // Push event to engine buffer for temporal/sequence rules
    let eventType = event.type === 'enter' ? 'geofence_enter' : 'geofence_exit';
    this.engine.pushEvent(eventType);

    // GPS é«˜ç²¾åº¦è¿›å…¥å›´æ æ—¶ï¼Œå­¦ä¹  WiFi/BT ä¿¡å·
    if (event.type === 'enter') {
      this.locationFusion.learnSignals(event.geofence.id, event.location);
    }

    // åªå¤„ç†è¿›å…¥äº‹ä»¶
    if (event.type !== 'enter') return;

    // åˆ·æ–°æ‰˜ç›˜ + é€šè¿‡ C++ è§„åˆ™å¼•æ“è¯„ä¼°
    await this.refreshTray();
    let snapshot = this.tray.getSnapshot();
    this.log.info(TAG, `Geofence trigger evaluate: geofence=${snapshot.geofence ?? 'none'}`);
    await this.evaluateAndDeliver(snapshot);
    
    this.evaluateAndDeliver(snapshot);

    // åŒæ—¶å°è¯•æ—§çš„ BehaviorLogger åŒ¹é…ï¼ˆå…¼å®¹è¿‡æ¸¡ï¼‰
    let ctx = await this.getCurrentContext();
    let rules = this.behaviorLog.getMatchingRules(ctx);
    if (rules.length > 0) {
      let topRule = rules[0];
      if (!this.isOnCooldown(topRule.id)) {
        let rec: ContextRecommendation = {
          rule: topRule,
          action: topRule.action,
          reason: this.buildRecommendationReason(topRule, event.geofence),
        };
        this.notifyRecommendation(rec);
        this.setOnCooldown(topRule.id);
      }
    } else {
      this.handleNewLocationWithoutRules(event.geofence, ctx);
    }
  }
  
  /**
   * å¤„ç†æ²¡æœ‰è§„åˆ™çš„æ–°ä½ç½® - åŸºäºä½ç½®ç±»å‹çš„é»˜è®¤æ¨è
   */
  private handleNewLocationWithoutRules(geofence: Geofence, ctx: EnvironmentContext): void {
    let defaultAction: UserAction | undefined;
    let reason: string = '';
    
    switch (geofence.category) {
      case 'transit':
        defaultAction = { type: 'show_qrcode', target: 'transit_code' };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼Œéœ€è¦ä¹˜è½¦ç å—ï¼Ÿ`;
        break;
        
      case 'shopping':
        let store = (geofence.metadata && geofence.metadata['store']) ? geofence.metadata['store'] as string : 'store';
        defaultAction = { type: 'show_info', target: `deals_${store}` };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼ŒæŸ¥çœ‹ä»Šæ—¥ä¼˜æƒ ï¼Ÿ`;
        break;
        
      case 'work':
        defaultAction = { type: 'show_info', target: 'calendar_today' };
        reason = `åˆ°è¾¾åŠå…¬å®¤ï¼ŒæŸ¥çœ‹ä»Šæ—¥æ—¥ç¨‹ï¼Ÿ`;
        break;
        
      default:
        return;  // ä¸æ¨è
    }
    
    if (defaultAction && !this.isOnCooldown(`default_${geofence.id}`)) {
      let rec: ContextRecommendation = {
        rule: {
          id: `default_${geofence.id}`,
          trigger: { geofenceIds: [geofence.id] },
          action: defaultAction,
          confidence: 0.5,  // é»˜è®¤æ¨èçš„åˆå§‹ç½®ä¿¡åº¦
          triggerCount: 0,
          acceptCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          enabled: true,
        },
        action: defaultAction,
        reason,
      };
      
      this.notifyRecommendation(rec);
      this.setOnCooldown(`default_${geofence.id}`);
    }
  }
  
  private buildRecommendationReason(rule: ContextRule, geofence: Geofence): string {
    let conf = Math.round(rule.confidence * 100);
    
    if (rule.action.type === 'show_qrcode') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œæ˜¾ç¤ºä¹˜è½¦ç ï¼Ÿ(${conf}% åŒ¹é…)`;
    } else if (rule.action.type === 'show_info') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œä¸ºä½ å‡†å¤‡äº†ç›¸å…³ä¿¡æ¯ (${conf}% åŒ¹é…)`;
    } else {
      return `åŸºäºä½ çš„ä¹ æƒ¯ï¼Œæ¨èæ­¤æ“ä½œ (${conf}% åŒ¹é…)`;
    }
  }
  
  
  /**
   * Convert a ContextSnapshot into ContextCondition[] for rule persistence.
   * Extracts the key fields that defined this context moment.
   */
  private snapshotToConditions(snapshot: ContextSnapshot): EngineCondition[] {
    let conditions: EngineCondition[] = [];

    // Time of day
    conditions.push({ key: 'timeOfDay', op: 'eq', value: snapshot.timeOfDay });

    // Hour range: Â±1 hour for flexibility
    let hour = parseInt(snapshot.hour);
    if (!isNaN(hour)) {
      let low = Math.max(0, hour - 1);
      let high = Math.min(23, hour + 1);
      conditions.push({ key: 'hour', op: 'range', value: `${low},${high}` });
    }

    // Weekend
    conditions.push({ key: 'isWeekend', op: 'eq', value: snapshot.isWeekend });

    // Motion state
    if (snapshot.motionState && snapshot.motionState !== 'unknown') {
      conditions.push({ key: 'motionState', op: 'eq', value: snapshot.motionState });
    }

    // Battery (only if notably low)
    let battery = parseInt(snapshot.batteryLevel);
    if (!isNaN(battery) && battery <= 20) {
      conditions.push({ key: 'batteryLevel', op: 'lte', value: '20' });
    }

    // Charging
    if (snapshot.isCharging === 'true') {
      conditions.push({ key: 'isCharging', op: 'eq', value: 'true' });
    }

    // Network
    if (snapshot.networkType && snapshot.networkType !== 'unknown') {
      conditions.push({ key: 'networkType', op: 'eq', value: snapshot.networkType });
    }

    // Geofence
    if (snapshot.geofence && snapshot.geofence.length > 0) {
      conditions.push({ key: 'geofence', op: 'eq', value: snapshot.geofence });
    }

    return conditions;
  }

  private isOnCooldown(ruleId: string): boolean {
    let lastTime = this.lastRecommendations.get(ruleId);
    if (!lastTime) return false;
    return Date.now() - lastTime < ContextAwarenessService.RECOMMENDATION_COOLDOWN_MS;
  }
  
  private setOnCooldown(ruleId: string): void {
    this.lastRecommendations.set(ruleId, Date.now());
  }
  

  /**
   * ç”¨æˆ·å¯¹æ¨èçš„åé¦ˆï¼ˆä¿ç•™æ—§ API å…¼å®¹æ€§ï¼‰
   */
  async onRecommendationFeedback(
    rec: ContextRecommendation,
    accepted: boolean
  ): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();

    let outcome: ActionOutcome = {
      accepted,
      feedback: accepted ? 1 : -1,
    };

    // è®°å½•è¡Œä¸º
    await this.behaviorLog.logBehavior(ctx, rec.action, outcome);

    this.log.info(TAG, 'Recommendation feedback: ' + rec.rule.id + ' accepted=' + accepted.toString());
  }

  /**
   * å¡ç‰‡å±•ç¤ºæ—¶é€šçŸ¥ FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
   */
  onCardShown(rec: ContextRecommendation): void {
    this.feedbackSvc.onCardShown(rec);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward +1.0
   */
  async onThumbsUp(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsUp(ruleId, ctx);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward -0.5
   */
  async onThumbsDown(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsDown(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ‰§è¡Œæ¨èåŠ¨ä½œ â†’ reward +0.8
   */
  async onActionTaken(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onActionTaken(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ»‘èµ°å¡ç‰‡ â†’ 5min å reward -0.1
   */
  onCardDismissed(ruleId: string): void {
    this.feedbackSvc.onCardDismissed(ruleId);
  }

  /**
   * è·å–åé¦ˆç»Ÿè®¡
   */
  getFeedbackStats(): FeedbackStats {
    return this.feedbackSvc.getStats();
  }
  
  
  addRecommendationListener(listener: RecommendationListener): void {
    this.recommendationListeners.push(listener);
  }
  
  removeRecommendationListener(listener: RecommendationListener): void {
    let idx = this.recommendationListeners.indexOf(listener);
    if (idx >= 0) this.recommendationListeners.splice(idx, 1);
  }
  
  private notifyRecommendation(rec: ContextRecommendation): void {
    this.log.info(TAG, 'Recommendation: ' + rec.reason);
    // æ³¨å†Œå¡ç‰‡åˆ° FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
    this.feedbackSvc.onCardShown(rec);
    for (let i = 0; i < this.recommendationListeners.length; i++) {
      try {
        this.recommendationListeners[i](rec);
      } catch (err) {
        this.log.warn(TAG, 'Listener error: ' + (err as Error).message);
      }
    }
  }
  
  // ==================== A2UI æœ¬åœ°åˆ†å‘ ====================
  
  addA2UIListener(listener: (type: string, content: string) => void): void {
    this.a2uiListeners.push(listener);
  }
  
  removeA2UIListener(listener: (type: string, content: string) => void): void {
    let idx = this.a2uiListeners.indexOf(listener);
    if (idx >= 0) this.a2uiListeners.splice(idx, 1);
  }
  
  dispatchA2UI(type: string, content: string): void {
    this.log.info(TAG, `dispatchA2UI: type=${type} contentLen=${content.length} listeners=${this.a2uiListeners.length}`);
    for (let i = 0; i < this.a2uiListeners.length; i++) {
      try {
        this.a2uiListeners[i](type, content);
      } catch (err) {
        this.log.warn(TAG, 'A2UI listener error: ' + (err as Error).message);
      }
    }
  }
  
  
  /**
   * æ‰‹åŠ¨è®°å½•ç”¨æˆ·è¡Œä¸ºï¼ˆç”¨äºå­¦ä¹ ç”¨æˆ·ä¹ æƒ¯ï¼‰
   */
  async recordUserAction(action: UserAction, accepted: boolean = true): Promise<void> {
    let ctx = await this.getCurrentContext();
    let outcome: ActionOutcome = { accepted, feedback: accepted ? 1 : 0 };
    await this.behaviorLog.logBehavior(ctx, action, outcome);
  }
  
  
  addGeofence(geofence: Geofence): void {
    this.geofenceMgr.addGeofence(geofence);
    this.geofenceMgr.saveToFile();
    this.rebindAfterGeofenceChange();
  }
  
  removeGeofence(id: string): boolean {
    let result = this.geofenceMgr.removeGeofence(id);
    if (result) {
      this.geofenceMgr.saveToFile();
      this.rebindAfterGeofenceChange();
    }
    return result;
  }

  private rebindAfterGeofenceChange(): void {
    try {
      let geofences = this.geofenceMgr.getAllGeofences();
      let bindings: GeofenceBinding[] = [];
      for (let i = 0; i < geofences.length; i++) {
        bindings.push({ id: geofences[i].id, category: geofences[i].category });
      }
      this.engine.rebindGeofences(bindings);
      this.log.info(TAG, `å›´æ å˜æ›´åé‡æ–°ç»‘å®šè§„åˆ™ï¼Œå›´æ æ•°: ${geofences.length}`);
    } catch (err) {
      this.log.warn(TAG, `rebind failed: ${(err as Error).message}`);
    }
  }
  
  getAllGeofences(): Geofence[] {
    return this.geofenceMgr.getAllGeofences();
  }
  
  

  /** è·å–æ‰€æœ‰å›´æ çš„å·²å­¦ä¹ ä¿¡å·æ‘˜è¦ï¼ˆç”¨äºè®¾ç½®é¡µå±•ç¤ºï¼‰ */
  getLearnedSignalsSummaries(): LearnedSignalsSummary[] {
    return this.locationFusion.getLearnedSignalsSummaries(this.geofenceMgr.getAllGeofences());
  }

  /** æ¸…é™¤æŸä¸ªå›´æ çš„å·²å­¦ä¹ ä¿¡å· */
  async clearLearnedSignals(geofenceId: string): Promise<void> {
    await this.locationFusion.clearLearnedSignals(geofenceId);
  }

  /** æ¸…é™¤æ‰€æœ‰å·²å­¦ä¹ ä¿¡å· */
  async clearAllLearnedSignals(): Promise<void> {
    await this.locationFusion.clearAllLearnedSignals();
  }



  addSuggestionListener(listener: SuggestionListener): void {
    this.suggestionListeners.push(listener);
  }

  removeSuggestionListener(listener: SuggestionListener): void {
    let idx = this.suggestionListeners.indexOf(listener);
    if (idx >= 0) this.suggestionListeners.splice(idx, 1);
  }

  private notifySuggestionListeners(suggestions: GeofenceSuggestion[]): void {
    for (let i = 0; i < this.suggestionListeners.length; i++) {
      try {
        this.suggestionListeners[i](suggestions);
      } catch (err) {
        this.log.warn(TAG, 'Suggestion listener error: ' + (err as Error).message);
      }
    }
  }

  /**
   * Filter raw suggestions: remove blacklisted, deferred (< 7 days), daily-cooled,
   * and clusters that already have a matching geofence.
   */
  private filterSuggestions(raw: GeofenceSuggestion[]): GeofenceSuggestion[] {
    let now = Date.now();
    let existingGeofences = this.geofenceMgr.getAllGeofences();
    let result: GeofenceSuggestion[] = [];

    for (let i = 0; i < raw.length; i++) {
      let s = raw[i];

      // Skip blacklisted
      if (this.suggestionState.blacklist.indexOf(s.id) >= 0) continue;

      // Skip deferred (within 7 days)
      let deferredAt = this.suggestionState.deferred[s.id];
      if (deferredAt !== undefined && (now - deferredAt) < DEFER_DURATION_MS) continue;

      // Skip daily cooldown (already shown today)
      let lastShown = this.suggestionState.lastShown[s.id];
      if (lastShown !== undefined && (now - lastShown) < DAILY_COOLDOWN_MS) continue;

      // Skip if a geofence already covers this cluster (within 200m)
      let alreadyCovered = false;
      for (let gi = 0; gi < existingGeofences.length; gi++) {
        let gf = existingGeofences[gi];
        let dist = this.haversineDistance(s.latitude, s.longitude, gf.latitude, gf.longitude);
        if (dist < 200) {
          alreadyCovered = true;
          break;
        }
      }
      if (alreadyCovered) continue;

      result.push(s);
    }

    return result;
  }

  /**
   * Accept a suggestion: create geofence with the user's chosen name/category.
   */
  acceptSuggestion(suggestion: GeofenceSuggestion, name: string, category: string): void {
    let gf: Geofence = {
      id: 'auto_' + Date.now().toString(),
      name: name,
      latitude: suggestion.latitude,
      longitude: suggestion.longitude,
      radiusMeters: suggestion.radiusMeters,
      category: category as GeofenceCategory,
    };
    this.addGeofence(gf);
    this.log.info(TAG, `Accepted suggestion "${name}" as geofence ${gf.id}`);
  }

  /**
   * Ignore a suggestion permanently (blacklist).
   */
  ignoreSuggestion(clusterId: string): void {
    if (this.suggestionState.blacklist.indexOf(clusterId) < 0) {
      this.suggestionState.blacklist.push(clusterId);
    }
    // Clean up deferred/lastShown entries
    this.suggestionState.deferred[clusterId] = 0;
    this.suggestionState.lastShown[clusterId] = 0;
    this.saveSuggestionState();
    this.log.info(TAG, `Blacklisted suggestion: ${clusterId}`);
  }

  /**
   * Defer a suggestion ("ä»¥åå†è¯´") â€” may resurface after 7 days.
   */
  deferSuggestion(clusterId: string): void {
    this.suggestionState.deferred[clusterId] = Date.now();
    this.saveSuggestionState();
    this.log.info(TAG, `Deferred suggestion: ${clusterId}`);
  }

  /**
   * Get currently actionable suggestions (filtered).
   */
  getFilteredSuggestions(): GeofenceSuggestion[] {
    let raw = this.locationDiscovery.getSuggestions();
    return this.filterSuggestions(raw);
  }


  private async loadSuggestionState(): Promise<void> {
    if (!this.context) return;
    try {
      let store = await preferences.getPreferences(this.context, Constants.PREFS_GEOFENCE_SUGGEST);
      let json = (await store.get(SUGGEST_PREFS_KEY, '')) as string;
      if (json.length > 0) {
        let parsed = JSON.parse(json) as GeofenceSuggestionState;
        this.suggestionState = {
          blacklist: parsed.blacklist || [],
          deferred: parsed.deferred || {},
          lastShown: parsed.lastShown || {},
        };
      }
      this.suggestionStateLoaded = true;
      this.log.info(TAG, `Loaded suggestion state: ${this.suggestionState.blacklist.length} blacklisted`);
    } catch (err) {
      this.log.warn(TAG, `Failed to load suggestion state: ${(err as Error).message}`);
      this.suggestionStateLoaded = true;
    }
  }

  private saveSuggestionState(): void {
    if (!this.context) return;
    let json = JSON.stringify(this.suggestionState);
    preferences.getPreferences(this.context, Constants.PREFS_GEOFENCE_SUGGEST).then((store) => {
      return store.put(SUGGEST_PREFS_KEY, json).then(() => store.flush());
    }).catch((err: Error) => {
      this.log.warn(TAG, `Failed to save suggestion state: ${err.message}`);
    });
  }


  /**
   * æ¨¡æ‹Ÿæƒ…æ™¯æ™ºèƒ½å®Œæ•´ UI æé†’æµç¨‹ï¼ˆå« cooldown æ£€æŸ¥ã€notifyRecommendationã€ç³»ç»Ÿé€šçŸ¥ï¼‰
   * ç”¨äºè°ƒè¯•ï¼šä¸ evaluateAndDeliver èµ°ç›¸åŒè·¯å¾„ï¼Œä½†è¿”å›åŒ¹é…ç»“æœä¾›è°ƒç”¨æ–¹æ£€æŸ¥ã€‚
   */
  async simulateContext(snapshot: ContextSnapshot): Promise<MatchResult[]> {
    await this.evaluateAndDeliver(snapshot);
    // è¿”å›å¼•æ“åŒ¹é…ç»“æœï¼ˆevaluateAndDeliver å†…éƒ¨å·²å¤„ç†æ¨é€ï¼‰
    return this.engine.evaluate(snapshot, 3);
  }

  getStatus(): string {
    let stats = this.behaviorLog.getStats();
    return `Running: ${this.isRunning}, ` +
           `Geofences: ${this.geofenceMgr.getAllGeofences().length}, ` +
           `Records: ${stats.totalRecords}, ` +
           `Rules: ${stats.enabledRules}/${stats.totalRules}, ` +
           `AvgConf: ${(stats.avgConfidence * 100).toFixed(0)}%`;
  }

  /** è·å–æ•°æ®æ‰˜ç›˜çŠ¶æ€ï¼ˆè°ƒè¯•ç”¨ï¼‰ */
  getTrayStatus(): TrayStatus[] {
    return this.tray.getStatus();
  }
  
  isActive(): boolean {
    return this.isRunning;
  }

  /** Access digital world service for plugin status/control */
  getDigitalWorldService(): DigitalWorldService {
    return this.digitalWorld;
  }

  /** Get last collected digital plugin data (merged key-value pairs) */
  getLastDigitalData(): Record<string, string> {
    return this.lastDigitalData;
  }
}
