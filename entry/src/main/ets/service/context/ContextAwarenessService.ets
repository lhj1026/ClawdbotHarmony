/**
 * Context Awareness Service
 * 
 * æ ¸å¿ƒæœåŠ¡ï¼šæ•´åˆä¼ æ„Ÿå™¨ã€åœ°ç†å›´æ ã€è¡Œä¸ºè®°å½•å’Œæ¨è
 */
import { sensor } from '@kit.SensorServiceKit';
import { batteryInfo } from '@kit.BasicServicesKit';
import { wifiManager } from '@kit.ConnectivityKit';
import { common } from '@kit.AbilityKit';
import { LogService } from '../../common/LogService';
import { GeofenceManager, GeofenceEvent } from './GeofenceManager';
import { BehaviorLogger } from './BehaviorLogger';
import { ContextEngineService, ContextSnapshot, MatchResult, GeofenceBinding } from './ContextEngine';
import { LocationDiscoveryService, GeofenceSuggestion, DiscoveryStatsInfo } from './LocationDiscoveryService';
import { FeedbackService } from './FeedbackService';
import { DigitalWorldService } from './DigitalWorldService';
import {
  EnvironmentContext,
  MotionState,
  TimeOfDay,
  NetworkType,
  UserAction,
  ActionOutcome,
  ContextRule,
  RuleTrigger,
  Geofence,
  LocationState,
  FeedbackStats,
} from './ContextModels';

const TAG = 'ContextService';

export interface ContextRecommendation {
  rule: ContextRule;
  action: UserAction;
  reason: string;
}

type RecommendationListener = (rec: ContextRecommendation) => void;

/** åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨æ•°æ®æ¥å£ */
interface AccelerometerData {
  x: number;
  y: number;
  z: number;
}

export class ContextAwarenessService {
  private static instance: ContextAwarenessService;
  private log: LogService = LogService.getInstance();
  
  private geofenceMgr: GeofenceManager;
  private behaviorLog: BehaviorLogger;
  private feedbackSvc: FeedbackService;
  
  private initialized: boolean = false;
  private isRunning: boolean = false;
  private context: common.UIAbilityContext | undefined;
  
  // å½“å‰çŠ¶æ€
  private currentContext: EnvironmentContext | undefined;
  private lastLocation: LocationState | undefined;
  private lastMotionState: MotionState = 'unknown';
  
  // ä¼ æ„Ÿå™¨æ•°æ®
  private accelerometerData: AccelerometerData = { x: 0, y: 0, z: 0 } as AccelerometerData;
  private stepCount: number = 0;
  
  // æ¨èç›‘å¬å™¨
  private recommendationListeners: RecommendationListener[] = [];
  
  // C++ è§„åˆ™å¼•æ“
  private engine: ContextEngineService = ContextEngineService.getInstance();
  private evaluationTimer: number = -1;
  private static readonly EVALUATION_INTERVAL_MS = 5 * 60 * 1000;  // 5åˆ†é’Ÿè¯„ä¼°ä¸€æ¬¡
  
  // é˜²æŠ–ï¼šé¿å…é‡å¤æ¨è
  private lastRecommendations: Map<string, number> = new Map();
  private static readonly RECOMMENDATION_COOLDOWN_MS = 5 * 60 * 1000;  // 5åˆ†é’Ÿå†·å´
  
  // ä½ç½®è‡ªåŠ¨å‘ç°
  private locationDiscovery: LocationDiscoveryService = LocationDiscoveryService.getInstance();
  private discoveryTimer: number = -1;
  private static readonly DISCOVERY_INTERVAL_MS = 60 * 60 * 1000;  // 1å°æ—¶å‘ç°ä¸€æ¬¡

  // æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
  private digitalWorld: DigitalWorldService = DigitalWorldService.getInstance();

  private constructor() {
    this.geofenceMgr = GeofenceManager.getInstance();
    this.behaviorLog = BehaviorLogger.getInstance();
    this.feedbackSvc = FeedbackService.getInstance();
  }
  
  static getInstance(): ContextAwarenessService {
    if (!ContextAwarenessService.instance) {
      ContextAwarenessService.instance = new ContextAwarenessService();
    }
    return ContextAwarenessService.instance;
  }
  
  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = context;
    
    await this.geofenceMgr.init(context);
    await this.behaviorLog.init(context);
    
    // åˆå§‹åŒ– C++ è§„åˆ™å¼•æ“
    await this.engine.init(context);
    if (this.engine.getRuleCount() === 0) {
      await this.engine.loadDefaultRules();
      this.log.info(TAG, `Loaded default rules: ${this.engine.getRuleCount()}`);
    }
    
    // åˆå§‹åŒ–ä½ç½®å‘ç°æœåŠ¡
    await this.locationDiscovery.init(context);
    await this.feedbackSvc.init(context);

    // åˆå§‹åŒ–æ•°å­—ä¸–ç•Œæ„ŸçŸ¥æœåŠ¡
    // TODO [Digital World Integration]: DigitalWorldService provides digital context
    // (calendar events, screen state, audio scene, etc.) that enriches the ContextSnapshot.
    // Currently initialized and polled independently; data is merged in buildSnapshot().
    await this.digitalWorld.init(context);

    // ç›‘å¬åœ°ç†å›´æ äº‹ä»¶
    this.geofenceMgr.addListener((event) => this.onGeofenceEvent(event));

    this.initialized = true;
    this.log.info(TAG, `Context Awareness Service initialized, rules: ${this.engine.getRuleCount()}`);
  }
  
  
  async start(): Promise<boolean> {
    if (this.isRunning) return true;
    if (!this.initialized) {
      this.log.error(TAG, 'Service not initialized');
      return false;
    }
    
    try {
      // å¯åŠ¨ä½ç½®ç›‘æ§
      await this.geofenceMgr.startMonitoring();
      
      // å¯åŠ¨ä¼ æ„Ÿå™¨
      this.startMotionSensors();
      
      // å¯åŠ¨å®šæ—¶è§„åˆ™è¯„ä¼°
      this.startPeriodicEvaluation();

      // å¯åŠ¨ä½ç½®è‡ªåŠ¨å‘ç°ï¼ˆå®šæ—¶èšç±»ï¼‰
      this.startLocationDiscovery();

      // å¯åŠ¨æ•°å­—ä¸–ç•Œæ„ŸçŸ¥
      this.digitalWorld.start();

      this.isRunning = true;
      this.log.info(TAG, 'Context Awareness Service started');
      return true;
    } catch (err) {
      this.log.error(TAG, `Failed to start: ${(err as Error).message}`);
      return false;
    }
  }
  
  stop(): void {
    if (!this.isRunning) return;
    
    this.geofenceMgr.stopMonitoring();
    this.stopMotionSensors();
    this.stopPeriodicEvaluation();
    this.stopLocationDiscovery();
    this.digitalWorld.stop();

    this.isRunning = false;
    this.log.info(TAG, 'Context Awareness Service stopped');
  }
  
  
  private startMotionSensors(): void {
    try {
      // åŠ é€Ÿåº¦è®¡ - ç”¨äºè¿åŠ¨çŠ¶æ€æ£€æµ‹
      sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {
        this.accelerometerData = { x: data.x, y: data.y, z: data.z } as AccelerometerData;
        this.updateMotionState();
      }, { interval: 1000000000 });  // 1ç§’é‡‡æ ·
      
      // è®¡æ­¥å™¨
      sensor.on(sensor.SensorId.PEDOMETER, (data: sensor.PedometerResponse) => {
        this.stepCount = data.steps;
      }, { interval: 5000000000 });  // 5ç§’é‡‡æ ·
      
      this.log.info(TAG, 'Motion sensors started');
    } catch (err) {
      this.log.warn(TAG, `Sensor error: ${(err as Error).message}`);
    }
  }
  
  private stopMotionSensors(): void {
    try {
      sensor.off(sensor.SensorId.ACCELEROMETER);
      sensor.off(sensor.SensorId.PEDOMETER);
    } catch {
      // ignore
    }
  }
  
  /**
   * åŸºäºåŠ é€Ÿåº¦è®¡æ•°æ®åˆ¤æ–­è¿åŠ¨çŠ¶æ€
   * ç®€åŒ–ç‰ˆæœ¬ï¼šä½¿ç”¨åŠ é€Ÿåº¦å¹…åº¦
   */
  private updateMotionState(): void {
    let x = this.accelerometerData.x;
    let y = this.accelerometerData.y;
    let z = this.accelerometerData.z;
    let magnitude = Math.sqrt(x * x + y * y + z * z);
    
    // ç®€å•é˜ˆå€¼åˆ¤æ–­ï¼ˆå®é™…åº”ç”¨éœ€è¦æ›´å¤æ‚çš„ç®—æ³•ï¼‰
    let newState: MotionState;
    
    if (magnitude < 10.5) {
      newState = 'stationary';
    } else if (magnitude < 12) {
      newState = 'walking';
    } else if (magnitude < 15) {
      newState = 'running';
    } else {
      // é«˜åŠ é€Ÿåº¦å¯èƒ½æ˜¯è½¦è¾†
      newState = this.lastLocation?.speed && this.lastLocation.speed > 5 ? 'driving' : 'walking';
    }
    
    if (newState !== this.lastMotionState) {
      this.log.debug(TAG, `Motion state: ${this.lastMotionState} -> ${newState}`);
      this.engine.pushEvent('motion_' + newState);
      this.lastMotionState = newState;
    }
  }


  private startPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) return;
    this.evaluationTimer = setInterval(() => {
      this.periodicEvaluate();
    }, ContextAwarenessService.EVALUATION_INTERVAL_MS);
    this.log.info(TAG, 'Started periodic evaluation');
  }

  private stopPeriodicEvaluation(): void {
    if (this.evaluationTimer !== -1) {
      clearInterval(this.evaluationTimer);
      this.evaluationTimer = -1;
      this.log.info(TAG, 'Stopped periodic evaluation');
    }
  }

  private async periodicEvaluate(): Promise<void> {
    if (!this.isRunning) return;
    let ctx = await this.getCurrentContext();
    let snapshot = this.buildSnapshot(ctx);
    this.evaluateAndDeliver(snapshot);
  }


  private startLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) return;

    // ç›‘å¬ä½ç½®å˜åŒ–ï¼Œè®°å½•åˆ°å‘ç°æœåŠ¡
    this.geofenceMgr.addLocationListener((location) => {
      this.locationDiscovery.recordLocation(location);
    });

    // å®šæ—¶è¿è¡Œèšç±»å‘ç°
    this.discoveryTimer = setInterval(() => {
      this.runLocationDiscovery();
    }, ContextAwarenessService.DISCOVERY_INTERVAL_MS);

    this.log.info(TAG, 'Started location discovery');
  }

  private stopLocationDiscovery(): void {
    if (this.discoveryTimer !== -1) {
      clearInterval(this.discoveryTimer);
      this.discoveryTimer = -1;
      this.log.info(TAG, 'Stopped location discovery');
    }
  }

  private async runLocationDiscovery(): Promise<void> {
    if (!this.isRunning) return;
    let suggestions = await this.locationDiscovery.runDiscovery();
    if (suggestions.length > 0) {
      this.log.info(TAG, `Location discovery found ${suggestions.length} suggestions`);
      // TODO: å¯ä»¥é€šè¿‡é€šçŸ¥æˆ–èŠå¤©æ¶ˆæ¯å‘ŠçŸ¥ç”¨æˆ·
    }
  }

  /** è·å–ä½ç½®å‘ç°å»ºè®® */
  getLocationSuggestions(): GeofenceSuggestion[] {
    return this.locationDiscovery.getSuggestions();
  }

  /** è·å–ä½ç½®å‘ç°ç»Ÿè®¡ */
  getLocationDiscoveryStats(): DiscoveryStatsInfo {
    return this.locationDiscovery.getStats();
  }

  
  /**
   * è·å–å½“å‰å®Œæ•´çš„ç¯å¢ƒä¸Šä¸‹æ–‡
   */
  async getCurrentContext(): Promise<EnvironmentContext> {
    let now = new Date();
    let hour = now.getHours();
    
    let timeOfDay: TimeOfDay;
    if (hour >= 5 && hour < 12) timeOfDay = 'morning';
    else if (hour >= 12 && hour < 17) timeOfDay = 'afternoon';
    else if (hour >= 17 && hour < 21) timeOfDay = 'evening';
    else timeOfDay = 'night';
    
    let dayOfWeek = now.getDay();
    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    
    // è®¾å¤‡çŠ¶æ€
    let batteryLevel = 100;
    let isCharging = false;
    try {
      batteryLevel = batteryInfo.batterySOC;
      isCharging = batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE;
    } catch {
      // ignore
    }
    
    // ç½‘ç»œçŠ¶æ€
    let networkType: NetworkType = 'none';
    try {
      if (wifiManager.isWifiActive()) {
        networkType = 'wifi';
      } else {
        networkType = 'cellular';  // ç®€åŒ–å¤„ç†
      }
    } catch {
      // ignore
    }
    
    // å½“å‰å›´æ 
    let currentGeofence: Geofence | undefined;
    if (this.lastLocation) {
      let geofences = this.geofenceMgr.getGeofencesAtLocation(
        this.lastLocation.latitude,
        this.lastLocation.longitude
      );
      currentGeofence = geofences[0];  // å–ç¬¬ä¸€ä¸ª
    }
    
    let ctx: EnvironmentContext = {
      timestamp: Date.now(),
      location: this.lastLocation,
      currentGeofence,
      motionState: this.lastMotionState,
      stepCount: this.stepCount,
      timeOfDay,
      dayOfWeek,
      isWeekend,
      batteryLevel,
      isCharging,
      networkType,
      screenOn: true,  // ç®€åŒ–å¤„ç†
    };
    
    this.currentContext = ctx;
    return ctx;
  }

  /**
   * æ„å»º C++ è§„åˆ™å¼•æ“éœ€è¦çš„å¿«ç…§æ ¼å¼
   *
   * TODO [Digital World Integration Point]:
   * Digital world data from DigitalWorldService is merged into the snapshot here.
   * The C++ engine's ContextSnapshot currently uses a fixed set of keys (timeOfDay,
   * hour, motionState, etc.), but the evaluate() method passes JSON so additional
   * digital-world keys (cal_hasUpcoming, audio_inCall, screen_locked, etc.) can be
   * matched by rules that reference these keys. New rules can use conditions like:
   *   { key: 'cal_inMeeting', op: 'eq', value: 'true' }
   *   { key: 'audio_inCall', op: 'eq', value: 'true' }
   *   { key: 'screen_locked', op: 'eq', value: 'true' }
   *
   * To fully wire this up:
   * 1. Extend ContextSnapshot interface in ContextEngine.ets with optional digital fields
   * 2. Add built-in rules that reference digital-world keys
   * 3. Connect DigitalWorldService lifecycle to this service (done â€” see init/start/stop)
   */
  private buildSnapshot(ctx: EnvironmentContext): ContextSnapshot {
    let now = new Date();
    let hour = now.getHours();
    let dayOfWeek = now.getDay();

    let snapshot: ContextSnapshot = {
      timeOfDay: ctx.timeOfDay,
      hour: hour.toString(),
      dayOfWeek: dayOfWeek.toString(),
      isWeekend: ctx.isWeekend ? 'true' : 'false',
      motionState: ctx.motionState || 'unknown',
      batteryLevel: ctx.batteryLevel.toString(),
      isCharging: ctx.isCharging ? 'true' : 'false',
      networkType: ctx.networkType || 'none',
      geofence: ctx.currentGeofence?.id,
      latitude: ctx.location?.latitude?.toString(),
      longitude: ctx.location?.longitude?.toString(),
      stepCount: ctx.stepCount?.toString()
    };

    // TODO [Digital World Integration]: Merge digital world data into snapshot.
    // When ContextSnapshot interface is extended with an index signature or
    // digital-specific fields, uncomment the following to enrich the snapshot:
    //
    // let digitalData = this.digitalWorld.getDigitalData();
    // let digitalKeys = Object.keys(digitalData);
    // for (let i = 0; i < digitalKeys.length; i++) {
    //   (snapshot as Record<string, string | undefined>)[digitalKeys[i]] = digitalData[digitalKeys[i]];
    // }

    return snapshot;
  }

  /**
   * è¯„ä¼°å¹¶æ¨é€æ¨è
   */
  private evaluateAndDeliver(snapshot: ContextSnapshot): void {
    let results = this.engine.evaluate(snapshot, 3);
    if (results.length === 0) return;

    let top = results[0];
    if (this.isOnCooldown(top.ruleId)) return;

    // è½¬æ¢ä¸ºæ¨èæ ¼å¼
    let rec: ContextRecommendation = {
      rule: {
        id: top.ruleId,
        trigger: {} as RuleTrigger,
        action: top.action as UserAction,
        confidence: top.confidence,
        triggerCount: 0,
        acceptCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        enabled: true
      },
      action: top.action as UserAction,
      reason: `åŸºäºå½“å‰æƒ…æ™¯æ¨è (${Math.round(top.confidence * 100)}% åŒ¹é…)`
    };

    this.notifyRecommendation(rec);
    this.setOnCooldown(top.ruleId);
  }

  
  private async onGeofenceEvent(event: GeofenceEvent): Promise<void> {
    this.log.info(TAG, `Geofence ${event.type}: ${event.geofence.name}`);
    
    // æ›´æ–°ä½ç½®
    this.lastLocation = event.location;
    
    // Push event to engine buffer for temporal/sequence rules
    let eventType = event.type === 'enter' ? 'geofence_enter' : 'geofence_exit';
    this.engine.pushEvent(eventType);
    
    // åªå¤„ç†è¿›å…¥äº‹ä»¶
    if (event.type !== 'enter') return;
    
    // è·å–å½“å‰ä¸Šä¸‹æ–‡å¹¶é€šè¿‡ C++ è§„åˆ™å¼•æ“è¯„ä¼°
    let ctx = await this.getCurrentContext();
    let snapshot = this.buildSnapshot(ctx);
    this.log.info(TAG, `Geofence trigger evaluate: geofence=${snapshot.geofence ?? 'none'}`);
    this.evaluateAndDeliver(snapshot);
    
    // åŒæ—¶å°è¯•æ—§çš„ BehaviorLogger åŒ¹é…ï¼ˆå…¼å®¹è¿‡æ¸¡ï¼‰
    let rules = this.behaviorLog.getMatchingRules(ctx);
    if (rules.length > 0) {
      let topRule = rules[0];
      if (!this.isOnCooldown(topRule.id)) {
        let rec: ContextRecommendation = {
          rule: topRule,
          action: topRule.action,
          reason: this.buildRecommendationReason(topRule, event.geofence),
        };
        this.notifyRecommendation(rec);
        this.setOnCooldown(topRule.id);
      }
    } else {
      this.handleNewLocationWithoutRules(event.geofence, ctx);
    }
  }
  
  /**
   * å¤„ç†æ²¡æœ‰è§„åˆ™çš„æ–°ä½ç½® - åŸºäºä½ç½®ç±»å‹çš„é»˜è®¤æ¨è
   */
  private handleNewLocationWithoutRules(geofence: Geofence, ctx: EnvironmentContext): void {
    let defaultAction: UserAction | undefined;
    let reason: string = '';
    
    switch (geofence.category) {
      case 'transit':
        defaultAction = { type: 'show_qrcode', target: 'transit_code' };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼Œéœ€è¦ä¹˜è½¦ç å—ï¼Ÿ`;
        break;
        
      case 'shopping':
        let store = (geofence.metadata && geofence.metadata['store']) ? geofence.metadata['store'] as string : 'store';
        defaultAction = { type: 'show_info', target: `deals_${store}` };
        reason = `åˆ°è¾¾ ${geofence.name}ï¼ŒæŸ¥çœ‹ä»Šæ—¥ä¼˜æƒ ï¼Ÿ`;
        break;
        
      case 'work':
        defaultAction = { type: 'show_info', target: 'calendar_today' };
        reason = `åˆ°è¾¾åŠå…¬å®¤ï¼ŒæŸ¥çœ‹ä»Šæ—¥æ—¥ç¨‹ï¼Ÿ`;
        break;
        
      default:
        return;  // ä¸æ¨è
    }
    
    if (defaultAction && !this.isOnCooldown(`default_${geofence.id}`)) {
      let rec: ContextRecommendation = {
        rule: {
          id: `default_${geofence.id}`,
          trigger: { geofenceIds: [geofence.id] },
          action: defaultAction,
          confidence: 0.5,  // é»˜è®¤æ¨èçš„åˆå§‹ç½®ä¿¡åº¦
          triggerCount: 0,
          acceptCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          enabled: true,
        },
        action: defaultAction,
        reason,
      };
      
      this.notifyRecommendation(rec);
      this.setOnCooldown(`default_${geofence.id}`);
    }
  }
  
  private buildRecommendationReason(rule: ContextRule, geofence: Geofence): string {
    let conf = Math.round(rule.confidence * 100);
    
    if (rule.action.type === 'show_qrcode') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œæ˜¾ç¤ºä¹˜è½¦ç ï¼Ÿ(${conf}% åŒ¹é…)`;
    } else if (rule.action.type === 'show_info') {
      return `åˆ°è¾¾ ${geofence.name}ï¼Œä¸ºä½ å‡†å¤‡äº†ç›¸å…³ä¿¡æ¯ (${conf}% åŒ¹é…)`;
    } else {
      return `åŸºäºä½ çš„ä¹ æƒ¯ï¼Œæ¨èæ­¤æ“ä½œ (${conf}% åŒ¹é…)`;
    }
  }
  
  
  private isOnCooldown(ruleId: string): boolean {
    let lastTime = this.lastRecommendations.get(ruleId);
    if (!lastTime) return false;
    return Date.now() - lastTime < ContextAwarenessService.RECOMMENDATION_COOLDOWN_MS;
  }
  
  private setOnCooldown(ruleId: string): void {
    this.lastRecommendations.set(ruleId, Date.now());
  }
  

  /**
   * ç”¨æˆ·å¯¹æ¨èçš„åé¦ˆï¼ˆä¿ç•™æ—§ API å…¼å®¹æ€§ï¼‰
   */
  async onRecommendationFeedback(
    rec: ContextRecommendation,
    accepted: boolean
  ): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();

    let outcome: ActionOutcome = {
      accepted,
      feedback: accepted ? 1 : -1,
    };

    // è®°å½•è¡Œä¸º
    await this.behaviorLog.logBehavior(ctx, rec.action, outcome);

    this.log.info(TAG, 'Recommendation feedback: ' + rec.rule.id + ' accepted=' + accepted.toString());
  }

  /**
   * å¡ç‰‡å±•ç¤ºæ—¶é€šçŸ¥ FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
   */
  onCardShown(rec: ContextRecommendation): void {
    this.feedbackSvc.onCardShown(rec);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward +1.0
   */
  async onThumbsUp(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsUp(ruleId, ctx);
  }

  /**
   * ğŸ‘ åé¦ˆ â†’ reward -0.5
   */
  async onThumbsDown(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onThumbsDown(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ‰§è¡Œæ¨èåŠ¨ä½œ â†’ reward +0.8
   */
  async onActionTaken(ruleId: string): Promise<void> {
    let ctx = this.currentContext ?? await this.getCurrentContext();
    await this.feedbackSvc.onActionTaken(ruleId, ctx);
  }

  /**
   * ç”¨æˆ·æ»‘èµ°å¡ç‰‡ â†’ 5min å reward -0.1
   */
  onCardDismissed(ruleId: string): void {
    this.feedbackSvc.onCardDismissed(ruleId);
  }

  /**
   * è·å–åé¦ˆç»Ÿè®¡
   */
  getFeedbackStats(): FeedbackStats {
    return this.feedbackSvc.getStats();
  }
  
  
  addRecommendationListener(listener: RecommendationListener): void {
    this.recommendationListeners.push(listener);
  }
  
  removeRecommendationListener(listener: RecommendationListener): void {
    let idx = this.recommendationListeners.indexOf(listener);
    if (idx >= 0) this.recommendationListeners.splice(idx, 1);
  }
  
  private notifyRecommendation(rec: ContextRecommendation): void {
    this.log.info(TAG, 'Recommendation: ' + rec.reason);
    // æ³¨å†Œå¡ç‰‡åˆ° FeedbackServiceï¼ˆå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨ï¼‰
    this.feedbackSvc.onCardShown(rec);
    for (let i = 0; i < this.recommendationListeners.length; i++) {
      try {
        this.recommendationListeners[i](rec);
      } catch (err) {
        this.log.warn(TAG, 'Listener error: ' + (err as Error).message);
      }
    }
  }
  
  
  /**
   * æ‰‹åŠ¨è®°å½•ç”¨æˆ·è¡Œä¸ºï¼ˆç”¨äºå­¦ä¹ ç”¨æˆ·ä¹ æƒ¯ï¼‰
   */
  async recordUserAction(action: UserAction, accepted: boolean = true): Promise<void> {
    let ctx = await this.getCurrentContext();
    let outcome: ActionOutcome = { accepted, feedback: accepted ? 1 : 0 };
    await this.behaviorLog.logBehavior(ctx, action, outcome);
  }
  
  
  addGeofence(geofence: Geofence): void {
    this.geofenceMgr.addGeofence(geofence);
    this.geofenceMgr.saveToFile();
    this.rebindAfterGeofenceChange();
  }
  
  removeGeofence(id: string): boolean {
    let result = this.geofenceMgr.removeGeofence(id);
    if (result) {
      this.geofenceMgr.saveToFile();
      this.rebindAfterGeofenceChange();
    }
    return result;
  }

  private rebindAfterGeofenceChange(): void {
    try {
      let geofences = this.geofenceMgr.getAllGeofences();
      let bindings: GeofenceBinding[] = [];
      for (let i = 0; i < geofences.length; i++) {
        bindings.push({ id: geofences[i].id, category: geofences[i].category });
      }
      this.engine.rebindGeofences(bindings);
      this.log.info(TAG, `å›´æ å˜æ›´åé‡æ–°ç»‘å®šè§„åˆ™ï¼Œå›´æ æ•°: ${geofences.length}`);
    } catch (err) {
      this.log.warn(TAG, `rebind failed: ${(err as Error).message}`);
    }
  }
  
  getAllGeofences(): Geofence[] {
    return this.geofenceMgr.getAllGeofences();
  }
  
  
  getStatus(): string {
    let stats = this.behaviorLog.getStats();
    return `Running: ${this.isRunning}, ` +
           `Geofences: ${this.geofenceMgr.getAllGeofences().length}, ` +
           `Records: ${stats.totalRecords}, ` +
           `Rules: ${stats.enabledRules}/${stats.totalRules}, ` +
           `AvgConf: ${(stats.avgConfidence * 100).toFixed(0)}%`;
  }
  
  isActive(): boolean {
    return this.isRunning;
  }

  /** Access digital world service for plugin status/control */
  getDigitalWorldService(): DigitalWorldService {
    return this.digitalWorld;
  }
}
