/**
 * Habit Chain Service
 * 
 * ç®¡ç†ä¹ æƒ¯é“¾ï¼šæŒ‰é¡ºåºæ‰§è¡Œçš„ä¹ æƒ¯åºåˆ—
 * ä¾‹ï¼šæ—©èµ·ä¹ æƒ¯ = [å–æ°´ â†’ åƒè”¬èœ â†’ åƒåšæœ]
 */
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { notificationManager } from '@kit.NotificationKit';
import { LogService } from '../../common/LogService';
import { 
  HabitChain, 
  HabitStep, 
  TimeTrigger,
} from './ContextModels';

const TAG = 'HabitChain';
const PREFS_NAME = 'clawdbot_habits';
const KEY_CHAINS = 'habit_chains';

type HabitEventListener = (chain: HabitChain, step: HabitStep, event: 'remind' | 'complete' | 'skip') => void;

export class HabitChainService {
  private static instance: HabitChainService;
  private log: LogService = LogService.getInstance();
  
  private chains: Map<string, HabitChain> = new Map();
  private timers: Map<string, number> = new Map();  // chainId -> timerId
  private listeners: HabitEventListener[] = [];
  private initialized: boolean = false;
  private context: common.UIAbilityContext | undefined;
  
  private constructor() {}
  
  static getInstance(): HabitChainService {
    if (!HabitChainService.instance) {
      HabitChainService.instance = new HabitChainService();
    }
    return HabitChainService.instance;
  }
  
  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = context;
    
    await this.loadChains(context);
    
    // æ·»åŠ ç¤ºä¾‹ä¹ æƒ¯é“¾
    if (this.chains.size === 0) {
      this.addDefaultChains();
    }
    
    // æ£€æŸ¥å¹¶é‡ç½®ä»Šæ—¥çŠ¶æ€
    this.resetDailyStatus();
    
    // å¯åŠ¨æ‰€æœ‰å¯ç”¨çš„ä¹ æƒ¯é“¾
    this.startAllChains();
    
    this.initialized = true;
    this.log.info(TAG, `Initialized with ${this.chains.size} habit chains`);
  }
  
  private addDefaultChains(): void {
    // ç¤ºä¾‹ï¼šæ—©èµ·å¥åº·ä¹ æƒ¯
    const morningChain: HabitChain = {
      id: 'morning_health',
      name: 'æ—©èµ·å¥åº·ä¹ æƒ¯',
      description: 'å¥åº·çš„æ—©æ™¨ä»è¿™é‡Œå¼€å§‹',
      triggerType: 'time',
      timeTrigger: {
        type: 'daily',
        time: '07:00',
        daysOfWeek: [1, 2, 3, 4, 5, 6, 0],  // æ¯å¤©
      },
      steps: [
        {
          id: 'drink_water',
          name: 'å–æ°´',
          description: 'èµ·åºŠåå–ä¸€æ¯æ¸©æ°´',
          completionType: 'manual',
          reminder: {
            message: 'â˜€ï¸ æ—©ä¸Šå¥½ï¼è¯¥å–ä¸€æ¯æ¸©æ°´äº†',
            type: 'notification',
            repeatIntervalMinutes: 10,
            maxRepeats: 3,
          },
          completedToday: false,
        },
        {
          id: 'eat_vegetables',
          name: 'åƒè”¬èœ',
          description: 'åƒä¸€äº›è”¬èœæˆ–æ²™æ‹‰',
          completionType: 'manual',
          reminder: {
            message: 'ğŸ¥— å–å®Œæ°´äº†ï¼Ÿæ¥ç‚¹è”¬èœè¡¥å……çº¤ç»´',
            type: 'notification',
            repeatIntervalMinutes: 15,
            maxRepeats: 2,
          },
          completedToday: false,
        },
        {
          id: 'eat_nuts',
          name: 'åƒåšæœ',
          description: 'ç°åœ¨å¯ä»¥åƒç‚¹åšæœäº†',
          completionType: 'manual',
          reminder: {
            message: 'ğŸ¥œ è”¬èœåƒå®Œäº†ï¼Ÿç°åœ¨å¯ä»¥åƒç‚¹åšæœ',
            type: 'notification',
            repeatIntervalMinutes: 20,
            maxRepeats: 2,
          },
          completedToday: false,
        },
      ],
      enabled: true,
      currentStepIndex: 0,
      lastResetDate: '',
      completionCount: 0,
      partialCount: 0,
      streakDays: 0,
    };
    
    this.chains.set(morningChain.id, morningChain);
    
    // ç¤ºä¾‹ï¼šç¡å‰ä¹ æƒ¯
    const nightChain: HabitChain = {
      id: 'night_routine',
      name: 'ç¡å‰æ”¾æ¾',
      description: 'å‡†å¤‡ä¸€ä¸ªå¥½ç¡çœ ',
      triggerType: 'time',
      timeTrigger: {
        type: 'daily',
        time: '22:00',
        daysOfWeek: [1, 2, 3, 4, 5, 6, 0],
      },
      steps: [
        {
          id: 'stop_screens',
          name: 'æ”¾ä¸‹æ‰‹æœº',
          description: 'å‡å°‘è“å…‰åˆºæ¿€',
          completionType: 'manual',
          reminder: {
            message: 'ğŸŒ™ æ˜¯æ—¶å€™æ”¾ä¸‹æ‰‹æœºäº†ï¼Œå‡†å¤‡ä¼‘æ¯',
            type: 'notification',
          },
          completedToday: false,
        },
        {
          id: 'drink_water_night',
          name: 'å–æ°´',
          description: 'ç¡å‰å–ä¸€å°æ¯æ°´',
          completionType: 'manual',
          reminder: {
            message: 'ğŸ’§ ç¡å‰å–ç‚¹æ°´',
            type: 'notification',
          },
          completedToday: false,
        },
      ],
      enabled: true,
      currentStepIndex: 0,
      lastResetDate: '',
      completionCount: 0,
      partialCount: 0,
      streakDays: 0,
    };
    
    this.chains.set(nightChain.id, nightChain);
  }
  
  // ==================== ä¹ æƒ¯é“¾ç®¡ç† ====================
  
  addChain(chain: HabitChain): void {
    this.chains.set(chain.id, chain);
    if (chain.enabled) {
      this.startChain(chain.id);
    }
    this.saveAsync();
    this.log.info(TAG, `Added chain: ${chain.name}`);
  }
  
  removeChain(id: string): boolean {
    this.stopChain(id);
    const removed = this.chains.delete(id);
    if (removed) {
      this.saveAsync();
    }
    return removed;
  }
  
  getChain(id: string): HabitChain | undefined {
    return this.chains.get(id);
  }
  
  getAllChains(): HabitChain[] {
    return Array.from(this.chains.values());
  }
  
  enableChain(id: string, enabled: boolean): void {
    const chain = this.chains.get(id);
    if (!chain) return;
    
    chain.enabled = enabled;
    if (enabled) {
      this.startChain(id);
    } else {
      this.stopChain(id);
    }
    this.saveAsync();
  }
  
  // ==================== æ­¥éª¤å®Œæˆ ====================
  
  /**
   * æ ‡è®°å½“å‰æ­¥éª¤å®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€æ­¥
   */
  completeCurrentStep(chainId: string): HabitStep | undefined {
    const chain = this.chains.get(chainId);
    if (!chain) return undefined;
    
    const currentStep = chain.steps[chain.currentStepIndex];
    if (!currentStep) return undefined;
    
    // æ ‡è®°å®Œæˆ
    currentStep.completedToday = true;
    currentStep.completedAt = Date.now();
    
    this.log.info(TAG, `Step completed: ${chain.name} / ${currentStep.name}`);
    this.notifyListeners(chain, currentStep, 'complete');
    
    // è¿›å…¥ä¸‹ä¸€æ­¥
    chain.currentStepIndex++;
    
    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨å®Œæˆ
    if (chain.currentStepIndex >= chain.steps.length) {
      this.onChainCompleted(chain);
    } else {
      // æé†’ä¸‹ä¸€æ­¥
      const nextStep = chain.steps[chain.currentStepIndex];
      this.remindStep(chain, nextStep);
    }
    
    this.saveAsync();
    return currentStep;
  }
  
  /**
   * è·³è¿‡å½“å‰æ­¥éª¤
   */
  skipCurrentStep(chainId: string): HabitStep | undefined {
    const chain = this.chains.get(chainId);
    if (!chain) return undefined;
    
    const currentStep = chain.steps[chain.currentStepIndex];
    if (!currentStep) return undefined;
    
    this.log.info(TAG, `Step skipped: ${chain.name} / ${currentStep.name}`);
    this.notifyListeners(chain, currentStep, 'skip');
    
    // è¿›å…¥ä¸‹ä¸€æ­¥ï¼ˆä¸æ ‡è®°å®Œæˆï¼‰
    chain.currentStepIndex++;
    
    if (chain.currentStepIndex >= chain.steps.length) {
      // éƒ¨åˆ†å®Œæˆ
      chain.partialCount++;
    } else {
      const nextStep = chain.steps[chain.currentStepIndex];
      this.remindStep(chain, nextStep);
    }
    
    this.saveAsync();
    return currentStep;
  }
  
  /**
   * è·å–å½“å‰éœ€è¦å®Œæˆçš„æ­¥éª¤
   */
  getCurrentStep(chainId: string): HabitStep | undefined {
    const chain = this.chains.get(chainId);
    if (!chain || chain.currentStepIndex >= chain.steps.length) {
      return undefined;
    }
    return chain.steps[chain.currentStepIndex];
  }
  
  private onChainCompleted(chain: HabitChain): void {
    const allCompleted = chain.steps.every(s => s.completedToday);
    
    if (allCompleted) {
      chain.completionCount++;
      chain.streakDays++;
      this.log.info(TAG, `Chain fully completed: ${chain.name} (streak: ${chain.streakDays})`);
      
      // å‘é€å®Œæˆé€šçŸ¥
      this.sendNotification(
        `ğŸ‰ ${chain.name} å®Œæˆï¼`,
        `å¤ªæ£’äº†ï¼è¿ç»­ ${chain.streakDays} å¤©å®Œæˆ`
      );
    } else {
      chain.partialCount++;
      chain.streakDays = 0;  // ä¸­æ–­è¿ç»­
      this.log.info(TAG, `Chain partially completed: ${chain.name}`);
    }
  }
  
  // ==================== å®šæ—¶è§¦å‘ ====================
  
  private startAllChains(): void {
    for (const chain of this.chains.values()) {
      if (chain.enabled) {
        this.startChain(chain.id);
      }
    }
  }
  
  private startChain(chainId: string): void {
    const chain = this.chains.get(chainId);
    if (!chain || !chain.timeTrigger) return;
    
    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
    this.stopChain(chainId);
    
    const trigger = chain.timeTrigger;
    
    if (trigger.type === 'daily' && trigger.time) {
      // è®¡ç®—ä¸‹æ¬¡è§¦å‘æ—¶é—´
      const nextTrigger = this.getNextDailyTrigger(trigger.time, trigger.daysOfWeek);
      const delay = nextTrigger - Date.now();
      
      if (delay > 0) {
        const timerId = setTimeout(() => {
          this.onChainTriggered(chainId);
        }, delay);
        
        this.timers.set(chainId, timerId);
        this.log.info(TAG, `Chain ${chain.name} scheduled for ${new Date(nextTrigger).toLocaleTimeString()}`);
      }
    }
  }
  
  private stopChain(chainId: string): void {
    const timerId = this.timers.get(chainId);
    if (timerId !== undefined) {
      clearTimeout(timerId);
      this.timers.delete(chainId);
    }
  }
  
  private getNextDailyTrigger(time: string, daysOfWeek?: number[]): number {
    const [hours, minutes] = time.split(':').map(Number);
    const now = new Date();
    const target = new Date();
    
    target.setHours(hours, minutes, 0, 0);
    
    // å¦‚æœä»Šå¤©çš„æ—¶é—´å·²è¿‡ï¼Œè®¾ç½®ä¸ºæ˜å¤©
    if (target.getTime() <= now.getTime()) {
      target.setDate(target.getDate() + 1);
    }
    
    // æ£€æŸ¥æ˜ŸæœŸ
    if (daysOfWeek && daysOfWeek.length > 0) {
      while (!daysOfWeek.includes(target.getDay())) {
        target.setDate(target.getDate() + 1);
      }
    }
    
    return target.getTime();
  }
  
  private onChainTriggered(chainId: string): void {
    const chain = this.chains.get(chainId);
    if (!chain || !chain.enabled) return;
    
    this.log.info(TAG, `Chain triggered: ${chain.name}`);
    
    // é‡ç½®ä»Šæ—¥çŠ¶æ€
    this.resetChainDaily(chain);
    
    // æé†’ç¬¬ä¸€æ­¥
    if (chain.steps.length > 0) {
      this.remindStep(chain, chain.steps[0]);
    }
    
    // é‡æ–°è°ƒåº¦æ˜å¤©
    this.startChain(chainId);
  }
  
  // ==================== æé†’ ====================
  
  private remindStep(chain: HabitChain, step: HabitStep): void {
    this.log.info(TAG, `Reminding: ${chain.name} / ${step.name}`);
    
    this.sendNotification(
      `${chain.name}`,
      step.reminder.message
    );
    
    this.notifyListeners(chain, step, 'remind');
  }
  
  private async sendNotification(title: string, content: string): Promise<void> {
    try {
      const request: notificationManager.NotificationRequest = {
        id: Date.now() % 100000,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title,
            text: content,
          },
        },
      };
      
      await notificationManager.publish(request);
    } catch (err) {
      this.log.warn(TAG, `Notification failed: ${(err as Error).message}`);
    }
  }
  
  // ==================== æ¯æ—¥é‡ç½® ====================
  
  private resetDailyStatus(): void {
    const today = new Date().toISOString().split('T')[0];
    
    for (const chain of this.chains.values()) {
      if (chain.lastResetDate !== today) {
        this.resetChainDaily(chain);
      }
    }
  }
  
  private resetChainDaily(chain: HabitChain): void {
    const today = new Date().toISOString().split('T')[0];
    
    // æ£€æŸ¥æ˜¨å¤©æ˜¯å¦å®Œæˆï¼ˆç”¨äºè¿ç»­å¤©æ•°ï¼‰
    if (chain.lastResetDate && chain.lastResetDate !== today) {
      const allCompleted = chain.steps.every(s => s.completedToday);
      if (!allCompleted) {
        chain.streakDays = 0;
      }
    }
    
    // é‡ç½®æ­¥éª¤çŠ¶æ€
    chain.currentStepIndex = 0;
    for (const step of chain.steps) {
      step.completedToday = false;
      step.completedAt = undefined;
    }
    chain.lastResetDate = today;
    
    this.log.info(TAG, `Reset daily status: ${chain.name}`);
  }
  
  // ==================== ç›‘å¬å™¨ ====================
  
  addListener(listener: HabitEventListener): void {
    this.listeners.push(listener);
  }
  
  removeListener(listener: HabitEventListener): void {
    const idx = this.listeners.indexOf(listener);
    if (idx >= 0) this.listeners.splice(idx, 1);
  }
  
  private notifyListeners(chain: HabitChain, step: HabitStep, event: 'remind' | 'complete' | 'skip'): void {
    for (const listener of this.listeners) {
      try {
        listener(chain, step, event);
      } catch {
        // ignore
      }
    }
  }
  
  // ==================== ç»Ÿè®¡ ====================
  
  getStats(): {
    totalChains: number;
    enabledChains: number;
    todayCompleted: number;
    todayTotal: number;
    longestStreak: number;
  } {
    let todayCompleted = 0;
    let todayTotal = 0;
    let longestStreak = 0;
    let enabledCount = 0;
    
    for (const chain of this.chains.values()) {
      if (!chain.enabled) continue;
      enabledCount++;
      
      for (const step of chain.steps) {
        todayTotal++;
        if (step.completedToday) todayCompleted++;
      }
      
      if (chain.streakDays > longestStreak) {
        longestStreak = chain.streakDays;
      }
    }
    
    return {
      totalChains: this.chains.size,
      enabledChains: enabledCount,
      todayCompleted,
      todayTotal,
      longestStreak,
    };
  }
  
  // ==================== æŒä¹…åŒ– ====================
  
  private async saveAsync(): Promise<void> {
    if (!this.context) return;
    try {
      const store = await preferences.getPreferences(this.context, PREFS_NAME);
      const data = JSON.stringify(Array.from(this.chains.entries()));
      await store.put(KEY_CHAINS, data);
      await store.flush();
    } catch (err) {
      this.log.warn(TAG, `Failed to save: ${(err as Error).message}`);
    }
  }
  
  private async loadChains(context: common.UIAbilityContext): Promise<void> {
    try {
      const store = await preferences.getPreferences(context, PREFS_NAME);
      const data = await store.get(KEY_CHAINS, '[]') as string;
      const entries = JSON.parse(data) as [string, HabitChain][];
      this.chains = new Map(entries);
    } catch (err) {
      this.log.warn(TAG, `Failed to load: ${(err as Error).message}`);
    }
  }
}
