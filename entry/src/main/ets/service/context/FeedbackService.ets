/**
 * FeedbackService.ets â€” æ¨èåé¦ˆç®¡ç†æœåŠ¡
 *
 * èŒè´£ï¼š
 *   - æ”¶é›†æ˜¾å¼åé¦ˆï¼ˆğŸ‘/ğŸ‘ï¼‰å’Œéšå¼åé¦ˆï¼ˆæ‰§è¡ŒåŠ¨ä½œ/å¿½ç•¥/è¶…æ—¶ï¼‰
 *   - è°ƒç”¨ ContextEngine.feedback() ä¼ é€’ MAB reward
 *   - è®°å½•åé¦ˆåˆ° BehaviorLogger
 *   - ç®¡ç†å¡ç‰‡çš„è¶…æ—¶å®šæ—¶å™¨ï¼ˆdismiss 5min / ignore 10minï¼‰
 *   - æä¾›åé¦ˆç»Ÿè®¡æ•°æ®ä¾› ContextSettingsPage ä½¿ç”¨
 */
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { LogService } from '../../common/LogService';
import { ContextEngineService } from './ContextEngine';
import { BehaviorLogger } from './BehaviorLogger';
import {
  FeedbackRecord,
  FeedbackStats,
  FeedbackRuleStat,
  FeedbackType,
  EnvironmentContext,
  ActionOutcome,
  UserAction,
} from './ContextModels';
import { ContextRecommendation } from './ContextAwarenessService';

interface RuleAggData {
  total: number;
  count: number;
}

const TAG = 'FeedbackService';
const PREFS_NAME = 'clawdbot_feedback';
const KEY_RECORDS = 'feedback_records';
const MAX_RECORDS = 500;

// å¥–åŠ±å€¼å¸¸é‡
const REWARD_THUMBS_UP = 1.0;
const REWARD_THUMBS_DOWN = -0.5;
const REWARD_ACTION_TAKEN = 0.8;
const REWARD_DISMISSED = -0.1;
const REWARD_IGNORED = -0.2;

// è¶…æ—¶å¸¸é‡
const DISMISS_TIMEOUT_MS = 5 * 60 * 1000;   // 5 åˆ†é’Ÿ
const IGNORE_TIMEOUT_MS = 10 * 60 * 1000;   // 10 åˆ†é’Ÿ

/** æ´»è·ƒå¡ç‰‡çš„è¿½è¸ªä¿¡æ¯ */
interface ActiveCard {
  rec: ContextRecommendation;
  shownAt: number;
  dismissTimerId: number;
  ignoreTimerId: number;
  resolved: boolean;
}

export class FeedbackService {
  private static instance: FeedbackService | null = null;
  private log: LogService = LogService.getInstance();
  private engine: ContextEngineService = ContextEngineService.getInstance();
  private behaviorLog: BehaviorLogger = BehaviorLogger.getInstance();

  private records: FeedbackRecord[] = [];
  private initialized: boolean = false;
  private context: common.UIAbilityContext | undefined;

  // æ´»è·ƒå¡ç‰‡è¿½è¸ªï¼šruleId -> ActiveCard
  private activeCards: Map<string, ActiveCard> = new Map();

  // è§„åˆ™åç§°ç¼“å­˜ï¼ˆç”¨äºç»Ÿè®¡æ˜¾ç¤ºï¼‰
  private ruleNames: Map<string, string> = new Map();

  /** Register a rule name for display in stats */
  setRuleName(ruleId: string, name: string): void {
    if (ruleId.length > 0 && name.length > 0) {
      this.ruleNames.set(ruleId, name);
    }
  }

  private constructor() {}

  static getInstance(): FeedbackService {
    if (!FeedbackService.instance) {
      FeedbackService.instance = new FeedbackService();
    }
    return FeedbackService.instance;
  }

  async init(appContext: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = appContext;
    await this.loadRecords();
    this.initialized = true;
    this.log.info(TAG, 'Initialized with ' + this.records.length.toString() + ' feedback records');
  }

  // ==================== å¡ç‰‡ç”Ÿå‘½å‘¨æœŸ ====================

  /**
   * å½“æ¨èå¡ç‰‡å±•ç¤ºæ—¶è°ƒç”¨ï¼Œå¯åŠ¨è¶…æ—¶å®šæ—¶å™¨
   */
  onCardShown(rec: ContextRecommendation): void {
    let ruleId = rec.rule.id;

    // æ¸…ç†å·²æœ‰çš„åŒ ruleId å®šæ—¶å™¨
    this.clearCardTimers(ruleId);

    // ç¼“å­˜è§„åˆ™åç§°
    let ruleName = rec.rule.trigger.geofenceIds
      ? 'rule_' + ruleId
      : ruleId;
    // å°è¯•ä½¿ç”¨ action target ä½œä¸ºæ›´å¯è¯»çš„åå­—
    if (rec.action.target) {
      ruleName = rec.action.target;
    }
    this.ruleNames.set(ruleId, ruleName);

    let card: ActiveCard = {
      rec: rec,
      shownAt: Date.now(),
      dismissTimerId: -1,
      ignoreTimerId: -1,
      resolved: false,
    };

    // 10 åˆ†é’Ÿæ— äº¤äº’ â†’ è‡ªåŠ¨è®°å½• ignored
    card.ignoreTimerId = setTimeout(() => {
      if (!card.resolved) {
        this.recordFeedback(ruleId, 'ignored', REWARD_IGNORED);
        card.resolved = true;
        this.activeCards.delete(ruleId);
      }
    }, IGNORE_TIMEOUT_MS) as number;

    this.activeCards.set(ruleId, card);
    this.log.info(TAG, 'Card shown: ' + ruleId);
  }

  /**
   * ç”¨æˆ·æ»‘èµ°/å…³é—­å¡ç‰‡ â†’ 5 åˆ†é’Ÿåè®°å½• dismiss æƒ©ç½š
   */
  onCardDismissed(ruleId: string): void {
    let card = this.activeCards.get(ruleId);
    if (!card || card.resolved) return;

    // æ¸…é™¤ ignore å®šæ—¶å™¨
    if (card.ignoreTimerId >= 0) {
      clearTimeout(card.ignoreTimerId);
    }

    // 5 åˆ†é’Ÿåç»™ dismiss æƒ©ç½š
    let dismissCard = card;
    card.dismissTimerId = setTimeout(() => {
      if (!dismissCard.resolved) {
        this.recordFeedback(ruleId, 'dismissed', REWARD_DISMISSED);
        dismissCard.resolved = true;
        this.activeCards.delete(ruleId);
      }
    }, DISMISS_TIMEOUT_MS) as number;

    this.log.info(TAG, 'Card dismissed: ' + ruleId + ' (reward in 5min)');
  }

  // ==================== æ˜¾å¼åé¦ˆ ====================

  /**
   * ç”¨æˆ·ç‚¹å‡» ğŸ‘
   */
  async onThumbsUp(ruleId: string, envContext?: EnvironmentContext): Promise<void> {
    this.resolveCard(ruleId);
    await this.recordFeedback(ruleId, 'thumbs_up', REWARD_THUMBS_UP);
    await this.logToBehavior(ruleId, true, envContext);
  }

  /**
   * ç”¨æˆ·ç‚¹å‡» ğŸ‘
   */
  async onThumbsDown(ruleId: string, envContext?: EnvironmentContext): Promise<void> {
    this.resolveCard(ruleId);
    await this.recordFeedback(ruleId, 'thumbs_down', REWARD_THUMBS_DOWN);
    await this.logToBehavior(ruleId, false, envContext);
  }

  /**
   * ç”¨æˆ·æ‰§è¡Œäº†æ¨èçš„åŠ¨ä½œï¼ˆå¦‚ç‚¹å‡»å¡ç‰‡æ‰“å¼€å¯¼èˆªï¼‰
   */
  async onActionTaken(ruleId: string, envContext?: EnvironmentContext): Promise<void> {
    this.resolveCard(ruleId);
    await this.recordFeedback(ruleId, 'action_taken', REWARD_ACTION_TAKEN);
    await this.logToBehavior(ruleId, true, envContext);
  }

  // ==================== ç»Ÿè®¡ ====================

  getStats(): FeedbackStats {
    let positiveCount = 0;
    let negativeCount = 0;
    let dismissCount = 0;
    let ignoreCount = 0;

    // æŒ‰ ruleId èšåˆ
    let ruleAgg: Map<string, RuleAggData> = new Map();

    for (let i = 0; i < this.records.length; i++) {
      let r = this.records[i];
      if (r.feedbackType === 'thumbs_up' || r.feedbackType === 'action_taken') {
        positiveCount++;
      } else if (r.feedbackType === 'thumbs_down') {
        negativeCount++;
      } else if (r.feedbackType === 'dismissed') {
        dismissCount++;
      } else if (r.feedbackType === 'ignored') {
        ignoreCount++;
      }

      let agg = ruleAgg.get(r.ruleId);
      if (agg) {
        agg.total += r.reward;
        agg.count++;
      } else {
        let newAgg: RuleAggData = { total: r.reward, count: 1 };
        ruleAgg.set(r.ruleId, newAgg);
      }
    }

    // Try to populate missing rule names from ContextEngine
    try {
      let engineRulesJson = this.engine.exportRules();
      if (engineRulesJson.length > 2) {
        let engineRules: Array<Record<string, Object>> = JSON.parse(engineRulesJson) as Array<Record<string, Object>>;
        for (let i = 0; i < engineRules.length; i++) {
          let r = engineRules[i];
          let id = r['id'] as string;
          let name = r['name'] as string;
          if (id && name && !this.ruleNames.has(id)) {
            this.ruleNames.set(id, name);
          }
        }
      }
    } catch { /* ignore */ }

    // æ’åº top rules by avg reward
    let ruleEntries: FeedbackRuleStat[] = [];
    ruleAgg.forEach((val: RuleAggData, key: string) => {
      ruleEntries.push({
        ruleId: key,
        ruleName: this.ruleNames.get(key) ?? key,
        totalReward: val.total,
        feedbackCount: val.count,
        avgReward: val.count > 0 ? val.total / val.count : 0,
      });
    });
    ruleEntries.sort((a: FeedbackRuleStat, b: FeedbackRuleStat) => b.avgReward - a.avgReward);

    let topRules = ruleEntries.slice(0, 3);

    let explicitTotal = positiveCount + negativeCount;
    let positiveRatio = explicitTotal > 0 ? positiveCount / explicitTotal : 0;

    return {
      totalCount: this.records.length,
      positiveCount: positiveCount,
      negativeCount: negativeCount,
      dismissCount: dismissCount,
      ignoreCount: ignoreCount,
      positiveRatio: positiveRatio,
      topRules: topRules,
    };
  }

  // ==================== å†…éƒ¨æ–¹æ³• ====================

  private resolveCard(ruleId: string): void {
    let card = this.activeCards.get(ruleId);
    if (card) {
      card.resolved = true;
      this.clearCardTimers(ruleId);
      this.activeCards.delete(ruleId);
    }
  }

  private clearCardTimers(ruleId: string): void {
    let card = this.activeCards.get(ruleId);
    if (!card) return;
    if (card.dismissTimerId >= 0) {
      clearTimeout(card.dismissTimerId);
    }
    if (card.ignoreTimerId >= 0) {
      clearTimeout(card.ignoreTimerId);
    }
  }

  private async recordFeedback(ruleId: string, feedbackType: FeedbackType, reward: number): Promise<void> {
    // å‘é€åˆ° C++ å¼•æ“
    try {
      await this.engine.feedback(ruleId, reward);
    } catch (err) {
      this.log.warn(TAG, 'Engine feedback failed: ' + (err as Error).message);
    }

    // å­˜æœ¬åœ°è®°å½•
    let record: FeedbackRecord = {
      id: 'fb_' + Date.now().toString() + '_' + Math.floor(Math.random() * 10000).toString(),
      ruleId: ruleId,
      timestamp: Date.now(),
      feedbackType: feedbackType,
      reward: reward,
    };
    this.records.push(record);

    if (this.records.length > MAX_RECORDS) {
      this.records = this.records.slice(this.records.length - MAX_RECORDS);
    }

    this.log.info(TAG, 'Feedback: ' + ruleId + ' type=' + feedbackType + ' reward=' + reward.toString());
    this.saveRecordsAsync();
  }

  private async logToBehavior(
    ruleId: string,
    accepted: boolean,
    envContext?: EnvironmentContext
  ): Promise<void> {
    if (!envContext) return;
    let card = this.activeCards.get(ruleId);
    let action = card ? card.rec.action : { type: 'dismiss', target: '' } as UserAction;
    let outcome: ActionOutcome = {
      accepted: accepted,
      feedback: accepted ? 1 : -1,
    };
    try {
      await this.behaviorLog.logBehavior(envContext, action, outcome);
    } catch (err) {
      this.log.warn(TAG, 'BehaviorLog failed: ' + (err as Error).message);
    }
  }

  // ==================== æŒä¹…åŒ– ====================

  private async loadRecords(): Promise<void> {
    if (!this.context) return;
    try {
      let store = await preferences.getPreferences(this.context, PREFS_NAME);
      let data = String(await store.get(KEY_RECORDS, '[]'));
      this.records = JSON.parse(data) as FeedbackRecord[];
    } catch (err) {
      this.log.warn(TAG, 'Load failed: ' + (err as Error).message);
    }
  }

  private async saveRecordsAsync(): Promise<void> {
    if (!this.context) return;
    try {
      let store = await preferences.getPreferences(this.context, PREFS_NAME);
      await store.put(KEY_RECORDS, JSON.stringify(this.records));
      await store.flush();
    } catch (err) {
      this.log.warn(TAG, 'Save failed: ' + (err as Error).message);
    }
  }
}
