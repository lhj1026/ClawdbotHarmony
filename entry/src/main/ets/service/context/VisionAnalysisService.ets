/**
 * Vision Analysis Service
 * 
 * è§†è§‰åˆ†ææœåŠ¡ï¼šå®šæ—¶æ‹ç…§ï¼ŒAI åˆ†æç”¨æˆ·è¡Œä¸º
 * ç”¨äºæ£€æµ‹ä¸å¥åº·çš„è¡Œä¸ºå¹¶ç»™äºˆæé†’
 * 
 * âš ï¸ éšç§æ³¨æ„ï¼šæ­¤åŠŸèƒ½éœ€è¦ç”¨æˆ·æ˜ç¡®æˆæƒ
 */
import { camera, cameraPicker } from '@kit.CameraKit';
import { image } from '@kit.ImageKit';
import { fileIo } from '@kit.CoreFileKit';
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { notificationManager } from '@kit.NotificationKit';
import { LogService } from '../../common/LogService';
import { 
  VisionAnalysisConfig, 
  VisionAnalysisResult, 
  HealthRule,
} from './ContextModels';

const TAG = 'VisionAnalysis';
const PREFS_NAME = 'clawdbot_vision';
const KEY_CONFIG = 'vision_config';
const KEY_RULES = 'health_rules';
const KEY_HISTORY = 'analysis_history';

type VisionAlertListener = (result: VisionAnalysisResult, rule: HealthRule) => void;

export class VisionAnalysisService {
  private static instance: VisionAnalysisService;
  private log: LogService = LogService.getInstance();
  
  private config: VisionAnalysisConfig;
  private rules: Map<string, HealthRule> = new Map();
  private history: VisionAnalysisResult[] = [];
  private captureTimer: number = -1;
  private isRunning: boolean = false;
  private initialized: boolean = false;
  private context: common.UIAbilityContext | undefined;
  
  private alertListeners: VisionAlertListener[] = [];
  
  // AI åˆ†æå›è°ƒï¼ˆç”±å¤–éƒ¨æ³¨å…¥ï¼Œè°ƒç”¨äº‘ç«¯ APIï¼‰
  private analyzeImageCallback: ((imagePath: string) => Promise<VisionAnalysisResult>) | undefined;
  
  private constructor() {
    // é»˜è®¤é…ç½®
    this.config = {
      enabled: false,  // é»˜è®¤å…³é—­ï¼Œéœ€è¦ç”¨æˆ·æ˜ç¡®å¼€å¯
      captureIntervalMinutes: 30,
      activeHours: {
        start: '07:00',
        end: '22:00',
      },
      onlyWhenScreenOn: true,
      deleteAfterAnalysis: true,
      localOnly: false,
    };
  }
  
  static getInstance(): VisionAnalysisService {
    if (!VisionAnalysisService.instance) {
      VisionAnalysisService.instance = new VisionAnalysisService();
    }
    return VisionAnalysisService.instance;
  }
  
  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.initialized) return;
    this.context = context;
    
    await this.loadConfig(context);
    await this.loadRules(context);
    await this.loadHistory(context);
    
    // æ·»åŠ é»˜è®¤å¥åº·è§„åˆ™
    if (this.rules.size === 0) {
      this.addDefaultRules();
    }
    
    this.initialized = true;
    this.log.info(TAG, `Initialized: ${this.rules.size} rules, history: ${this.history.length}`);
  }
  
  private addDefaultRules(): void {
    const defaultRules: HealthRule[] = [
      {
        id: 'unhealthy_snacks',
        name: 'é¿å…é«˜çƒ­é‡é›¶é£Ÿ',
        triggerKeywords: ['è–¯ç‰‡', 'chips', 'å¯ä¹', 'cola', 'soda', 'ç³–æœ', 'candy', 'å·§å…‹åŠ›', 'chocolate', 'é¥¼å¹²', 'cookies', 'å†°æ·‡æ·‹', 'ice cream'],
        exceptKeywords: ['åšæœ', 'nuts', 'æ°´æœ', 'fruit', 'è”¬èœ', 'vegetable'],
        warningMessage: 'ğŸŸ æ£€æµ‹åˆ°é«˜çƒ­é‡é›¶é£Ÿï¼Œå»ºè®®æ¢æˆå¥åº·é£Ÿå“',
        suggestionMessage: 'è¯•è¯•åšæœã€æ°´æœæˆ–é…¸å¥¶',
        severity: 'warning',
        enabled: true,
      },
      {
        id: 'sedentary',
        name: 'é¿å…ä¹…å',
        triggerKeywords: ['æ²™å‘', 'couch', 'sofa', 'èººç€', 'lying', 'çœ‹ç”µè§†', 'watching TV', 'ç©æ‰‹æœº', 'phone'],
        activeTimeRanges: [
          { start: '09:00', end: '12:00' },
          { start: '14:00', end: '17:00' },
        ],
        warningMessage: 'ğŸ§˜ å·²ç»åäº†ä¸€æ®µæ—¶é—´ï¼Œèµ·æ¥æ´»åŠ¨ä¸€ä¸‹ï¼Ÿ',
        suggestionMessage: 'ç«™èµ·æ¥èµ°åŠ¨5åˆ†é’Ÿï¼Œåšåšä¼¸å±•',
        severity: 'info',
        enabled: true,
      },
      {
        id: 'late_night_eating',
        name: 'é¿å…æ·±å¤œè¿›é£Ÿ',
        triggerKeywords: ['åƒ', 'eating', 'é£Ÿç‰©', 'food', 'é›¶é£Ÿ', 'snack'],
        activeTimeRanges: [
          { start: '22:00', end: '23:59' },
          { start: '00:00', end: '06:00' },
        ],
        warningMessage: 'ğŸŒ™ æ·±å¤œè¿›é£Ÿä¸åˆ©äºæ¶ˆåŒ–å’Œç¡çœ ',
        suggestionMessage: 'å¦‚æœé¥¿äº†ï¼Œå–ç‚¹æ°´æˆ–åƒç‚¹æ°´æœ',
        severity: 'warning',
        enabled: true,
      },
      {
        id: 'poor_posture',
        name: 'å§¿åŠ¿æé†’',
        triggerKeywords: ['ä½å¤´', 'head down', 'é©¼èƒŒ', 'hunched', 'è¶´ç€', 'lying face down'],
        warningMessage: 'ğŸ“± æ³¨æ„å§¿åŠ¿ï¼æŠ¬èµ·å¤´æ¥',
        suggestionMessage: 'ä¿æŒå±å¹•ä¸çœ¼ç›å¹³é½ï¼ŒèƒŒéƒ¨æŒºç›´',
        severity: 'info',
        enabled: true,
      },
    ];
    
    for (const rule of defaultRules) {
      this.rules.set(rule.id, rule);
    }
  }
  
  // ==================== é…ç½®ç®¡ç† ====================
  
  getConfig(): VisionAnalysisConfig {
    return { ...this.config };
  }
  
  async updateConfig(newConfig: Partial<VisionAnalysisConfig>): Promise<void> {
    this.config = { ...this.config, ...newConfig };
    await this.saveConfig();
    
    // é‡å¯æœåŠ¡ä»¥åº”ç”¨æ–°é…ç½®
    if (this.isRunning) {
      this.stop();
      if (this.config.enabled) {
        this.start();
      }
    }
  }
  
  // ==================== è§„åˆ™ç®¡ç† ====================
  
  addRule(rule: HealthRule): void {
    this.rules.set(rule.id, rule);
    this.saveRulesAsync();
  }
  
  removeRule(id: string): boolean {
    const removed = this.rules.delete(id);
    if (removed) this.saveRulesAsync();
    return removed;
  }
  
  getRule(id: string): HealthRule | undefined {
    return this.rules.get(id);
  }
  
  getAllRules(): HealthRule[] {
    return Array.from(this.rules.values());
  }
  
  enableRule(id: string, enabled: boolean): void {
    const rule = this.rules.get(id);
    if (rule) {
      rule.enabled = enabled;
      this.saveRulesAsync();
    }
  }
  
  // ==================== æœåŠ¡æ§åˆ¶ ====================
  
  /**
   * è®¾ç½® AI å›¾åƒåˆ†æå›è°ƒ
   * å¤–éƒ¨å®ç°è°ƒç”¨äº‘ç«¯ APIï¼ˆå¦‚ GPT-4 Visionï¼‰
   */
  setAnalyzeCallback(callback: (imagePath: string) => Promise<VisionAnalysisResult>): void {
    this.analyzeImageCallback = callback;
  }
  
  start(): boolean {
    if (this.isRunning) return true;
    if (!this.config.enabled) {
      this.log.warn(TAG, 'Vision analysis is disabled');
      return false;
    }
    if (!this.analyzeImageCallback) {
      this.log.warn(TAG, 'No analyze callback set');
      return false;
    }
    
    const intervalMs = this.config.captureIntervalMinutes * 60 * 1000;
    
    this.captureTimer = setInterval(() => {
      this.captureAndAnalyze();
    }, intervalMs);
    
    this.isRunning = true;
    this.log.info(TAG, `Started: interval=${this.config.captureIntervalMinutes}min`);
    return true;
  }
  
  stop(): void {
    if (!this.isRunning) return;
    
    if (this.captureTimer >= 0) {
      clearInterval(this.captureTimer);
      this.captureTimer = -1;
    }
    
    this.isRunning = false;
    this.log.info(TAG, 'Stopped');
  }
  
  // ==================== æ‹ç…§åˆ†æ ====================
  
  /**
   * æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡åˆ†æ
   */
  async triggerAnalysis(): Promise<VisionAnalysisResult | undefined> {
    return this.captureAndAnalyze();
  }
  
  private async captureAndAnalyze(): Promise<VisionAnalysisResult | undefined> {
    // æ£€æŸ¥æ´»è·ƒæ—¶é—´
    if (!this.isWithinActiveHours()) {
      this.log.debug(TAG, 'Outside active hours, skipping');
      return undefined;
    }
    
    // TODO: æ£€æŸ¥å±å¹•çŠ¶æ€
    // if (this.config.onlyWhenScreenOn && !isScreenOn()) return;
    
    try {
      // æ‹ç…§
      const imagePath = await this.capturePhoto();
      if (!imagePath) {
        this.log.warn(TAG, 'Failed to capture photo');
        return undefined;
      }
      
      // åˆ†æ
      if (!this.analyzeImageCallback) {
        this.log.warn(TAG, 'No analyze callback');
        return undefined;
      }
      
      const result = await this.analyzeImageCallback(imagePath);
      result.imagePath = imagePath;
      
      this.log.info(TAG, `Analysis: ${result.description}`);
      
      // æ£€æŸ¥å¥åº·è§„åˆ™
      await this.checkHealthRules(result);
      
      // ä¿å­˜å†å²
      this.history.push(result);
      if (this.history.length > 100) {
        this.history = this.history.slice(-100);
      }
      this.saveHistoryAsync();
      
      // åˆ é™¤ç…§ç‰‡ï¼ˆå¦‚æœé…ç½®ï¼‰
      if (this.config.deleteAfterAnalysis) {
        try {
          await fileIo.unlink(imagePath);
        } catch {
          // ignore
        }
      }
      
      return result;
    } catch (err) {
      this.log.error(TAG, `Analysis failed: ${(err as Error).message}`);
      return undefined;
    }
  }
  
  private async capturePhoto(): Promise<string | undefined> {
    // ä½¿ç”¨å‰ç½®æ‘„åƒå¤´æ‹ç…§
    // æ³¨æ„ï¼šå®é™…å®ç°éœ€è¦æ›´å®Œæ•´çš„ç›¸æœºæ§åˆ¶
    try {
      // ç®€åŒ–å®ç°ï¼šç”Ÿæˆä¸´æ—¶æ–‡ä»¶è·¯å¾„
      const timestamp = Date.now();
      const path = `${this.context?.filesDir}/vision_${timestamp}.jpg`;
      
      // TODO: å®é™…çš„ç›¸æœºæ‹ç…§é€»è¾‘
      // è¿™é‡Œéœ€è¦ä½¿ç”¨ CameraCapability çš„åŠŸèƒ½
      this.log.debug(TAG, `Would capture photo to: ${path}`);
      
      // æš‚æ—¶è¿”å› undefinedï¼Œç­‰å®é™…ç›¸æœºå®ç°
      return undefined;
    } catch (err) {
      this.log.error(TAG, `Capture failed: ${(err as Error).message}`);
      return undefined;
    }
  }
  
  private isWithinActiveHours(): boolean {
    const now = new Date();
    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    
    const { start, end } = this.config.activeHours;
    return currentTime >= start && currentTime <= end;
  }
  
  // ==================== å¥åº·è§„åˆ™æ£€æŸ¥ ====================
  
  private async checkHealthRules(result: VisionAnalysisResult): Promise<void> {
    const now = new Date();
    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    
    const allText = [
      result.description,
      ...result.detectedActivities,
      ...result.detectedObjects,
    ].join(' ').toLowerCase();
    
    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue;
      
      // æ£€æŸ¥æ—¶é—´èŒƒå›´
      if (rule.activeTimeRanges && rule.activeTimeRanges.length > 0) {
        const inRange = rule.activeTimeRanges.some(range => 
          currentTime >= range.start && currentTime <= range.end
        );
        if (!inRange) continue;
      }
      
      // æ£€æŸ¥è§¦å‘å…³é”®è¯
      const triggered = rule.triggerKeywords.some(kw => 
        allText.includes(kw.toLowerCase())
      );
      if (!triggered) continue;
      
      // æ£€æŸ¥æ’é™¤å…³é”®è¯
      if (rule.exceptKeywords && rule.exceptKeywords.length > 0) {
        const excepted = rule.exceptKeywords.some(kw => 
          allText.includes(kw.toLowerCase())
        );
        if (excepted) continue;
      }
      
      // è§¦å‘è­¦å‘Š
      this.log.info(TAG, `Rule triggered: ${rule.name}`);
      
      // æ›´æ–°ç»“æœ
      result.concerns = result.concerns || [];
      result.concerns.push(rule.warningMessage);
      
      if (rule.suggestionMessage) {
        result.suggestions = result.suggestions || [];
        result.suggestions.push(rule.suggestionMessage);
      }
      
      // å‘é€é€šçŸ¥
      await this.sendAlert(rule);
      
      // é€šçŸ¥ç›‘å¬å™¨
      this.notifyAlertListeners(result, rule);
    }
  }
  
  private async sendAlert(rule: HealthRule): Promise<void> {
    try {
      const request: notificationManager.NotificationRequest = {
        id: Date.now() % 100000,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: rule.name,
            text: rule.warningMessage + (rule.suggestionMessage ? `\n${rule.suggestionMessage}` : ''),
          },
        },
      };
      
      await notificationManager.publish(request);
    } catch (err) {
      this.log.warn(TAG, `Alert failed: ${(err as Error).message}`);
    }
  }
  
  // ==================== ç›‘å¬å™¨ ====================
  
  addAlertListener(listener: VisionAlertListener): void {
    this.alertListeners.push(listener);
  }
  
  removeAlertListener(listener: VisionAlertListener): void {
    const idx = this.alertListeners.indexOf(listener);
    if (idx >= 0) this.alertListeners.splice(idx, 1);
  }
  
  private notifyAlertListeners(result: VisionAnalysisResult, rule: HealthRule): void {
    for (const listener of this.alertListeners) {
      try {
        listener(result, rule);
      } catch {
        // ignore
      }
    }
  }
  
  // ==================== å†å²æŸ¥è¯¢ ====================
  
  getHistory(limit: number = 50): VisionAnalysisResult[] {
    return this.history.slice(-limit);
  }
  
  getTodayStats(): {
    captures: number;
    healthyCount: number;
    concernCount: number;
  } {
    const today = new Date().toISOString().split('T')[0];
    const todayResults = this.history.filter(r => 
      new Date(r.timestamp).toISOString().split('T')[0] === today
    );
    
    let concernCount = 0;
    for (const r of todayResults) {
      if (r.concerns && r.concerns.length > 0) {
        concernCount++;
      }
    }
    
    return {
      captures: todayResults.length,
      healthyCount: todayResults.length - concernCount,
      concernCount,
    };
  }
  
  // ==================== æŒä¹…åŒ– ====================
  
  private async saveConfig(): Promise<void> {
    if (!this.context) return;
    try {
      const store = await preferences.getPreferences(this.context, PREFS_NAME);
      await store.put(KEY_CONFIG, JSON.stringify(this.config));
      await store.flush();
    } catch (err) {
      this.log.warn(TAG, `Failed to save config: ${(err as Error).message}`);
    }
  }
  
  private async loadConfig(context: common.UIAbilityContext): Promise<void> {
    try {
      const store = await preferences.getPreferences(context, PREFS_NAME);
      const data = await store.get(KEY_CONFIG, '') as string;
      if (data) {
        this.config = { ...this.config, ...JSON.parse(data) };
      }
    } catch {
      // use defaults
    }
  }
  
  private async saveRulesAsync(): Promise<void> {
    if (!this.context) return;
    try {
      const store = await preferences.getPreferences(this.context, PREFS_NAME);
      await store.put(KEY_RULES, JSON.stringify(Array.from(this.rules.entries())));
      await store.flush();
    } catch (err) {
      this.log.warn(TAG, `Failed to save rules: ${(err as Error).message}`);
    }
  }
  
  private async loadRules(context: common.UIAbilityContext): Promise<void> {
    try {
      const store = await preferences.getPreferences(context, PREFS_NAME);
      const data = await store.get(KEY_RULES, '[]') as string;
      const entries = JSON.parse(data) as [string, HealthRule][];
      this.rules = new Map(entries);
    } catch {
      // use defaults
    }
  }
  
  private async saveHistoryAsync(): Promise<void> {
    if (!this.context) return;
    try {
      const store = await preferences.getPreferences(this.context, PREFS_NAME);
      await store.put(KEY_HISTORY, JSON.stringify(this.history));
      await store.flush();
    } catch {
      // ignore
    }
  }
  
  private async loadHistory(context: common.UIAbilityContext): Promise<void> {
    try {
      const store = await preferences.getPreferences(context, PREFS_NAME);
      const data = await store.get(KEY_HISTORY, '[]') as string;
      this.history = JSON.parse(data);
    } catch {
      // empty history
    }
  }
  
  // ==================== çŠ¶æ€ ====================
  
  isActive(): boolean {
    return this.isRunning;
  }
  
  getStatus(): string {
    const stats = this.getTodayStats();
    return `Running: ${this.isRunning}, Today: ${stats.captures} captures, ${stats.concernCount} concerns`;
  }
}
